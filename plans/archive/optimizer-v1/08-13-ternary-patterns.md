# Task 8.13: Ternary Operator Optimization Patterns

> **Task**: 8.13 (New - Ternary Operator)  
> **Time**: ~2 hours  
> **Tests**: ~35 tests  
> **Prerequisites**: Tasks 8.1-8.2 (Pattern Framework + Matcher), Phase 4 (Control Flow)

---

## Overview

This document describes optimization patterns specific to ternary operator (`?:`) expressions. The ternary operator generates a distinctive **diamond CFG pattern** with BRANCH and PHI instructions in SSA form:

```
┌─────────────────────┐
│   condition eval    │
│   BRANCH cond       │
│     /         \     │
│    ▼           ▼    │
│ true_block  false_block │
│  (value1)    (value2)   │
│    \           /    │
│     ▼         ▼     │
│   merge_block       │
│   PHI(v1,v2)        │
└─────────────────────┘
```

---

## IL Pattern Generated by Ternary

For source code:
```js
let result: byte = condition ? trueValue : falseValue;
```

The IL generator produces:
```
block_0:                          ; condition evaluation
  %0 = LOAD condition
  BRANCH %0, block_true, block_false

block_true:
  %1 = CONST trueValue
  JUMP block_merge

block_false:
  %2 = CONST falseValue
  JUMP block_merge

block_merge:
  %3 = PHI [%1, block_true], [%2, block_false]
  STORE result, %3
```

---

## Optimization Opportunities

### 1. Constant Condition Folding (Task 4.2 / Task 3.3)

When the condition is a compile-time constant, the entire ternary collapses.

**Before (constant true condition):**
```js
let x: byte = true ? 10 : 20;
```

**IL Before:**
```
  %0 = CONST 1          ; true
  BRANCH %0, block_true, block_false
block_true:
  %1 = CONST 10
  JUMP block_merge
block_false:
  %2 = CONST 20
  JUMP block_merge
block_merge:
  %3 = PHI [%1, block_true], [%2, block_false]
```

**IL After (constant propagation + branch fold + DCE):**
```
  %1 = CONST 10
```

**Optimization Chain:**
1. Constant propagation identifies `%0 = 1` (true)
2. Branch folding converts `BRANCH true` → `JUMP block_true`
3. DCE removes unreachable `block_false`
4. CFG simplification merges blocks
5. Dead PHI elimination (single incoming edge)

---

### 2. Diamond to Select Conversion (Task 4.6)

For simple ternary expressions, convert the diamond pattern to a conditional select (eliminates branching).

**Before (diamond pattern):**
```
  BRANCH %cond, block_true, block_false
block_true:
  %1 = CONST 10
  JUMP block_merge
block_false:
  %2 = CONST 20
  JUMP block_merge
block_merge:
  %3 = PHI [%1, block_true], [%2, block_false]
```

**After (select form):**
```
  %1 = CONST 10
  %2 = CONST 20
  %3 = SELECT %cond, %1, %2
```

**6502 Code Generation for SELECT:**
```asm
  ; SELECT generates branchless code when possible:
  LDA trueValue
  CPX #0        ; test condition (if in X)
  BEQ use_false
  BNE done
use_false:
  LDA falseValue
done:
  STA result
```

**Note:** For 6502, branching is often equally fast or faster than branchless for simple cases. The profitability heuristic should consider:
- Size of true/false blocks (must be single instruction each)
- Whether condition is already in flags
- Branch prediction (unlikely on 6502)

---

### 3. Ternary with Same Values (DCE Pattern)

When true and false branches produce the same value:

**Before:**
```js
let x: byte = cond ? 42 : 42;
```

**After:**
```js
let x: byte = 42;
```

**Pattern Detection:**
```typescript
// In PHI simplification (Task 4.3)
if (phi.getAllIncomingValues().every(v => v.equals(phi.getIncomingValue(0)))) {
  replaceAllUsesWith(phi, phi.getIncomingValue(0));
}
```

---

### 4. Nested Ternary Optimization

Nested ternary expressions can sometimes be simplified.

**Before:**
```js
let x: byte = a ? (b ? 1 : 2) : (b ? 1 : 2);
```

**After:**
```js
let x: byte = b ? 1 : 2;  // outer condition irrelevant
```

**Pattern:** When both branches of outer ternary have identical inner ternary.

---

### 5. Ternary Assignment Coalescing

When ternary assigns to same variable in both branches:

**Before (if-else form):**
```
if (cond) {
  x = a;
} else {
  x = b;
}
```

**This is already optimal ternary pattern.** No further optimization needed.

---

### 6. Comparison + Ternary Fusion (6502-Specific)

When condition is a comparison immediately followed by ternary:

**Before:**
```js
let min: byte = (a < b) ? a : b;
```

**IL:**
```
  %cmp = CMP_LT a, b
  BRANCH %cmp, block_true, block_false
  ...
```

**6502 Optimization - Fuse comparison into branch:**
```asm
  LDA a
  CMP b         ; Sets carry: C=1 if a >= b, C=0 if a < b
  BCC use_a     ; Branch if a < b (carry clear)
  LDA b         ; a >= b, so min is b
  JMP done
use_a:
  LDA a         ; a < b, so min is a
done:
  STA min
```

**Note:** This is more of a code generation pattern than IL optimization.

---

## Peephole Patterns for Ternary

### Pattern: Redundant PHI After Constant Branch

**Before:**
```
  BRANCH const_true, A, B
A:
  ...
  JUMP merge
B:
  ...           ; Unreachable!
  JUMP merge
merge:
  PHI [v1, A], [v2, B]   ; Only one predecessor reachable
```

**After:**
```
  JUMP A
A:
  ...
  ; PHI replaced with v1 directly
```

---

### Pattern: Boolean Ternary Simplification

**Before:**
```js
let x: boolean = cond ? true : false;
```

**After:**
```js
let x: boolean = cond;
```

**Pattern:**
```typescript
// PHI(true, false) for boolean condition → just use condition
if (isBoolean(phi.getType()) && 
    phi.getIncomingValue(0).isConstant(1) &&
    phi.getIncomingValue(1).isConstant(0)) {
  // Replace PHI with the branch condition
}
```

**Inverse:**
```js
let x: boolean = cond ? false : true;
// →
let x: boolean = !cond;
```

---

### Pattern: Arithmetic Identity via Ternary

**Before:**
```js
let x: byte = cond ? (a + 0) : (a + 0);
```

**After (constant folding + identity):**
```js
let x: byte = a;
```

---

## C64-Specific Ternary Patterns

### Min/Max via Ternary

```js
let min: byte = (a < b) ? a : b;
let max: byte = (a > b) ? a : b;
```

**Optimized 6502 for min:**
```asm
  LDA a
  CMP b
  BCC done      ; if a < b, A already has min
  LDA b
done:
  STA min
```

### Clamp via Nested Ternary

```js
let clamped: byte = (x < min) ? min : ((x > max) ? max : x);
```

**This is a common C64 pattern for sprite bounds, scroll limits, etc.**

### Direction Toggle

```js
let dir: byte = (dir == 0) ? 1 : 0;
```

**Optimized 6502:**
```asm
  LDA dir
  EOR #1        ; Toggle bit 0
  STA dir
```

---

## Integration with Existing Optimizer Phases

| Phase | Optimization | Ternary Impact |
|-------|--------------|----------------|
| 3.1 DCE | Dead code elimination | Removes unreachable ternary branches |
| 3.3 Constant Fold | Fold constant conditions | `true ? a : b` → `a` |
| 3.4 Constant Prop | Propagate constants | Enable constant branch folding |
| 3.7 CSE | Common subexpression | Reuse ternary results |
| 4.2 Branch Fold | Constant branch removal | Eliminate diamond for constant cond |
| 4.3 CFG Simplify | Merge blocks, simplify PHI | Clean up after ternary optimization |
| 4.6 If Convert | Diamond to select | Convert ternary pattern to SELECT |
| 8.5 Branch Peephole | Branch patterns | Optimize ternary branches |

---

## Test Cases Required

| Test | Description |
|------|-------------|
| `constant true condition` | `true ? 10 : 20` → `10` |
| `constant false condition` | `false ? 10 : 20` → `20` |
| `constant comparison` | `(1 < 2) ? a : b` → `a` |
| `same values both branches` | `c ? 42 : 42` → `42` |
| `boolean identity true/false` | `c ? true : false` → `c` |
| `boolean identity false/true` | `c ? false : true` → `!c` |
| `diamond to select simple` | Single-value branches → SELECT |
| `diamond to select complex` | Multi-instruction branches → no convert |
| `nested ternary identical` | `a ? (b?1:2) : (b?1:2)` → `b?1:2` |
| `nested ternary different` | No optimization (different branches) |
| `min pattern` | `(a<b) ? a : b` recognized |
| `max pattern` | `(a>b) ? a : b` recognized |
| `clamp pattern` | Nested min/max recognized |
| `direction toggle` | `d==0 ? 1 : 0` → `d ^ 1` |
| `ternary in expression` | `x + (c ? a : b)` |
| `ternary with side effects` | No optimization if side effects |
| `ternary type promotion` | Byte/word promotion handled |
| `dead phi elimination` | After branch fold, single-input PHI removed |
| `unreachable branch removal` | False branch removed after constant fold |
| `PHI cycle detection` | No infinite loops in optimization |
| `6502 comparison fusion` | CMP + ternary generates efficient code |

---

## Implementation Priority

1. **High Priority** (covered by existing phases):
   - Constant branch folding (Task 4.2)
   - Constant propagation (Task 3.4)
   - Dead code elimination (Task 3.1)
   - CFG simplification (Task 4.3)

2. **Medium Priority** (new patterns):
   - Boolean identity optimization
   - Same-value PHI simplification
   - Diamond to SELECT conversion (Task 4.6)

3. **Low Priority** (advanced):
   - Nested ternary fusion
   - 6502-specific comparison patterns
   - Min/max/clamp idiom recognition

---

## Task Checklist

| Item | Status |
|------|--------|
| Document ternary IL pattern | [x] |
| Map to existing optimizer phases | [x] |
| Define ternary-specific patterns | [x] |
| List test cases | [x] |
| Update Phase 4 with ternary notes | [ ] |
| Implement boolean identity pattern | [ ] |
| Implement same-value PHI simplification | [ ] |
| Write unit tests | [ ] |
| Integration tests | [ ] |

---

## Cross-References

- [03-classical-optimizations.md](03-classical-optimizations.md) - DCE, Constant Prop, CSE
- [04-control-flow.md](04-control-flow.md) - Branch Fold, If Conversion, CFG Simplify
- [08-05a-branch-core.md](08-05a-branch-core.md) - Branch peephole patterns
- [07-6502-specific.md](07-6502-specific.md) - 6502 comparison optimization

---

**Previous Task**: 8.12 → Pattern ordering optimization  
**Next Task**: 9.x → Target-specific optimizations