# Review Gaps Amendment: 2026-01-28

> **Document**: 20-review-gaps-2026-01-28.md
> **Parent**: [Index](00-index.md)
> **Date**: 2026-01-28
> **Purpose**: Address 6 gaps identified during comprehensive plan review
> **Status**: CRITICAL - Required for 100% working compiler

---

## Overview

During a strict and comprehensive review of the codegen-fixes plan against the Blend65 language specification, 6 additional gaps were identified. These gaps must be addressed to achieve a **true 100% working compiler**.

**Total New Tasks: 19 tasks**
**Estimated Additional Hours: 8-12 hours (~3-4 sessions)**

---

## Gap A: Unsigned Comparison Verification

### Problem

The language specification states all types are **unsigned**:
- `byte`: 0-255 (unsigned 8-bit)
- `word`: 0-65535 (unsigned 16-bit)

On the 6502, comparisons must use the correct branch instructions:
- `BCC/BCS` = unsigned comparison (correct for Blend65)
- `BMI/BPL` = signed comparison (WRONG for Blend65)

### What's Missing

The plan doesn't explicitly verify that comparison codegen uses unsigned semantics.

### Test Cases That Must Pass

```js
// These MUST evaluate correctly with unsigned semantics
let a: byte = 255;
let b: byte = 1;

// 255 > 1 should be TRUE (unsigned)
// If interpreted as signed (-1 > 1), it would be FALSE!
if (a > b) {
    result = 1;  // MUST execute
}

// After subtraction, 200 > 100 must still work
let x: byte = 200;
let y: byte = 100;
if (x > y) {
    result = 1;  // MUST execute
}
```

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| A.1 | Verify all comparison codegen uses BCC/BCS (unsigned) | `codegen/instruction-generator.ts` |
| A.2 | Test: `255 > 1` evaluates to TRUE | tests |
| A.3 | Test: `200 > 100` after arithmetic is correct | tests |
| A.4 | VICE test: Verify unsigned comparison at runtime | tests (VICE) |

### Implementation Pattern

For unsigned greater-than (`a > b`):
```asm
    LDA a_location
    CMP b_location    ; Compare A to memory
    BEQ not_greater   ; If equal, not greater
    BCS is_greater    ; If carry set, A >= B (unsigned)
    JMP not_greater
is_greater:
    ; a > b is TRUE
not_greater:
    ; a > b is FALSE
```

**NEVER use BMI/BPL for comparisons - these are signed!**

---

## Gap B: @zp Storage Class Allocation

### Problem

The plan defines Zero Page ranges for compiler use:
- $40-$4F: PHI merge (16 bytes)
- $50-$5F: Function parameters (16 bytes)
- $60-$7F or $9F: Spill area (32-64 bytes)
- $80+: Local variables

But it doesn't specify how **user-defined @zp variables** are allocated.

### What's Missing

```js
@zp let fastCounter: byte = 0;
@zp let playerX: byte = 10;
@zp let playerY: byte = 10;
```

These must:
1. Actually allocate in Zero Page ($00-$FF)
2. Not collide with compiler's reserved ZP ranges
3. Use ZP addressing mode in generated code

### User ZP Range

**Proposed allocation:**
- User @zp variables: $02-$3F (62 bytes available)
- This avoids:
  - $00-$01: CPU vectors
  - $40+: Compiler reserved

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| B.1 | Implement @zp variable allocation in range $02-$3F | `codegen/globals-generator.ts` |
| B.2 | Document user ZP range vs compiler ZP range | `codegen/base-generator.ts` |
| B.3 | Test: `@zp let x: byte` allocates address < $40 | tests |
| B.4 | Test: @zp variables use ZP addressing mode (2-byte instructions) | tests |
| B.5 | Test: ZP overflow produces meaningful error | tests |

### Implementation Pattern

```typescript
// In globals-generator.ts
protected readonly USER_ZP_START = 0x02;
protected readonly USER_ZP_END = 0x3F;
protected nextUserZpAddress = this.USER_ZP_START;

protected allocateUserZpVariable(name: string, size: number): number {
    if (this.nextUserZpAddress + size > this.USER_ZP_END) {
        this.addError(`Zero page overflow: ${name} (${size} bytes) exceeds available ZP space`);
        // Fall back to @ram
        return this.allocateRamVariable(name, size);
    }
    const address = this.nextUserZpAddress;
    this.nextUserZpAddress += size;
    return address;
}
```

---

## Gap C: Runtime Array Initialization

### Problem

The language specification shows arrays initialized with runtime expressions:

```js
let positions: byte[3] = [x, y + 1, z * 2];
let results: byte[2] = [calculate(1), calculate(2)];
```

These cannot be resolved at compile time - they require **runtime initialization code**.

### What's Missing

The plan covers:
- ✅ Constant array initialization (embedded in data section)
- ❌ Runtime-computed array initialization

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| C.1 | Detect arrays with non-constant initializers | `codegen/globals-generator.ts` |
| C.2 | Generate initialization code for runtime arrays | `codegen/instruction-generator.ts` |
| C.3 | Add initialization code to program startup | `codegen/code-generator.ts` |
| C.4 | Test: `let arr: byte[3] = [x, y, z]` initializes correctly | tests |
| C.5 | Test: `let arr: byte[2] = [func1(), func2()]` calls functions | tests |
| C.6 | VICE test: Verify runtime-initialized arrays | tests (VICE) |

### Implementation Pattern

For `let arr: byte[3] = [x, y, z]`:

```asm
; Generated initialization code (runs before main)
_init_arr:
    LDA x_location
    STA arr+0
    LDA y_location
    STA arr+1
    LDA z_location
    STA arr+2
    RTS
```

---

## Gap D: Interrupt Vector Documentation

### Problem

The specification shows callback functions for interrupt handlers:

```js
callback function myIRQ(): void {
    // handler code
}
```

But it doesn't specify **how to install the handler** at interrupt vectors ($FFFE for IRQ, $FFFA for NMI).

### Solution

This is **intentionally not automatic**. Users must manually install handlers using `pokew()`:

```js
// Install custom IRQ handler
pokew($0314, @myIRQ);  // C64 KERNAL IRQ vector

// Or for direct hardware vectors (with KERNAL disabled)
pokew($FFFE, @myIRQ);  // Hardware IRQ vector
```

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| D.1 | Document interrupt vector installation in language spec | `docs/language-specification/11-functions.md` |
| D.2 | Add example: Complete IRQ handler setup | `docs/language-specification/21-examples.md` |
| D.3 | Test: `pokew($0314, @myHandler)` compiles correctly | tests |

### Documentation to Add

```markdown
## Installing Interrupt Handlers

Blend65 does not automatically install interrupt handlers. Use `pokew()` to set up vectors:

### C64 KERNAL Vectors (Recommended)

```js
// Custom IRQ handler
callback function myIRQ(): void {
    // Handle interrupt
    vicBorderColor += 1;
}

function main(): void {
    // Install at KERNAL IRQ vector
    pokew($0314, @myIRQ);
    
    // Enable interrupts
    cli();
}
```

### Hardware Vectors (KERNAL Disabled)

```js
// Direct hardware IRQ (requires KERNAL disabled)
sei();
poke($01, $35);  // Disable KERNAL ROM
pokew($FFFE, @myIRQ);
cli();
```
```

---

## Gap E: Runtime Library Verification

### Problem

The plan references a runtime library containing multiply/divide/modulo routines, but doesn't specify:
1. Where is this library located?
2. How is it included in compiled output?
3. What routines exist?

### Current State

The runtime library should be in `packages/compiler/library/` but this needs verification.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| E.1 | Verify runtime library exists in `packages/compiler/library/` | verification |
| E.2 | Document runtime routines: `_multiply`, `_divide`, `_modulo` | docs |
| E.3 | Verify codegen includes runtime in output when needed | `codegen/code-generator.ts` |
| E.4 | Test: Multiplication generates JSR _multiply | tests |
| E.5 | Test: Division generates JSR _divide | tests |
| E.6 | VICE test: Multiply/divide produce correct results | tests (VICE) |

### Runtime Routines Reference

| Routine | Purpose | Inputs | Output |
|---------|---------|--------|--------|
| `_multiply` | 8-bit × 8-bit → 16-bit | A, X | A (low), X (high) |
| `_divide` | 8-bit ÷ 8-bit → 8-bit | A (dividend), X (divisor) | A (quotient) |
| `_modulo` | 8-bit mod 8-bit → 8-bit | A (dividend), X (divisor) | A (remainder) |

---

## Gap F: PRG Output Format

### Problem

For C64 programs to be loadable, the compiled output needs:
1. 2-byte load address header
2. Proper start address (typically $0801)
3. Optional BASIC stub for auto-run

### Solution

ACME assembler handles PRG format, but the codegen must emit correct directives.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| F.1 | Verify codegen emits `*=$0801` or configurable start address | `codegen/code-generator.ts` |
| F.2 | Verify ACME `-f cbm` flag produces PRG format | build scripts |
| F.3 | Test: Compiled output loads in VICE with `LOAD"*",8,1` | tests (VICE) |

### ACME Directives for PRG

```asm
; Start address for C64 PRG
* = $0801

; Optional BASIC stub for auto-run
!byte $0c, $08, $0a, $00, $9e  ; BASIC line
!text "2061"                    ; SYS 2061
!byte $00, $00, $00            ; End of BASIC

; Actual program starts here
* = $080d
main:
    ; ... program code ...
```

---

## Summary: All Review Gaps

| Gap | Description | Tasks | Est. Hours |
|-----|-------------|-------|------------|
| A | Unsigned Comparison Verification | 4 | 1-2 |
| B | @zp Storage Class Allocation | 5 | 2-3 |
| C | Runtime Array Initialization | 6 | 2-3 |
| D | Interrupt Vector Documentation | 3 | 1 |
| E | Runtime Library Verification | 6 | 2-3 |
| F | PRG Output Format | 3 | 1 |
| **TOTAL** | | **27** | **9-13** |

---

## Task Checklist

### Gap A: Unsigned Comparison
- [ ] A.1 Verify all comparisons use BCC/BCS (unsigned)
- [ ] A.2 Test: `255 > 1` evaluates to TRUE
- [ ] A.3 Test: `200 > 100` after arithmetic is correct
- [ ] A.4 VICE test: Verify unsigned comparison at runtime

### Gap B: @zp Storage Class
- [ ] B.1 Implement @zp allocation in range $02-$3F
- [ ] B.2 Document user ZP vs compiler ZP ranges
- [ ] B.3 Test: @zp variables allocate in ZP range
- [ ] B.4 Test: @zp uses ZP addressing mode
- [ ] B.5 Test: ZP overflow produces error

### Gap C: Runtime Array Initialization
- [ ] C.1 Detect arrays with non-constant initializers
- [ ] C.2 Generate initialization code for runtime arrays
- [ ] C.3 Add init code to program startup
- [ ] C.4 Test: `let arr = [x, y, z]` works
- [ ] C.5 Test: `let arr = [func1(), func2()]` works
- [ ] C.6 VICE test: Runtime-initialized arrays

### Gap D: Interrupt Vector Documentation
- [ ] D.1 Document interrupt installation in spec
- [ ] D.2 Add complete IRQ handler example
- [ ] D.3 Test: `pokew($0314, @handler)` compiles

### Gap E: Runtime Library
- [ ] E.1 Verify runtime library exists
- [ ] E.2 Document runtime routines
- [ ] E.3 Verify codegen includes runtime
- [ ] E.4 Test: Multiply generates JSR
- [ ] E.5 Test: Divide generates JSR
- [ ] E.6 VICE test: Multiply/divide correctness

### Gap F: PRG Output
- [ ] F.1 Verify codegen emits correct start address
- [ ] F.2 Verify ACME produces PRG format
- [ ] F.3 VICE test: Output loads correctly

---

## Updated Success Criteria

**After implementing this document PLUS all previous phases:**

1. ✅ All comparison operators use unsigned semantics
2. ✅ @zp storage class allocates in user ZP range
3. ✅ Runtime-initialized arrays work
4. ✅ Interrupt handler installation is documented
5. ✅ Runtime library is verified and documented
6. ✅ PRG output format is correct for C64

**NOW we can truly claim "100% working compiler".**

---

## Related Documents

- [Index](00-index.md) - Main plan index
- [Final Gaps](19-final-gaps-2026-01-28.md) - Previous gaps
- [Execution Plan](99-execution-plan.md) - Session schedule
- [Language Specification](../../docs/language-specification/) - Source of truth