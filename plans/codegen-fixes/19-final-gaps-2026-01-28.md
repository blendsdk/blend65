# Final Gaps Amendment: 2026-01-28

> **Document**: 19-final-gaps-2026-01-28.md
> **Parent**: [Index](00-index.md)
> **Date**: 2026-01-28
> **Purpose**: Address 11 FINAL gaps identified during comprehensive plan review
> **Status**: ALL GAPS ARE CRITICAL FOR 100% WORKING COMPILER

---

## ðŸš¨ CRITICAL: These Are The FINAL Gaps For 100% Completion

This document captures the **last 11 gaps** identified during a comprehensive review of the codegen-fixes plan against the Blend65 language specification. Addressing these gaps will achieve a **100% working compiler**.

---

## Gap 1: Stub Functions â†’ Compiler Intrinsics Mapping

**Clarification**: Stub functions map to compiler intrinsics. There is no traditional linker.

### Problem

The language specification shows stub functions (functions without bodies):
```js
function peek(address: word): byte;
function poke(address: word, value: byte): void;
```

### Solution

Stub functions are **compiler intrinsics** - the compiler recognizes them by name and generates inline code.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 1.G1.1 | Document all stub functions as intrinsics mapping | docs |
| 1.G1.2 | Verify semantic analyzer marks stub functions as intrinsic | `semantic/` |
| 1.G1.3 | Verify IL generator emits intrinsic IL for stub calls | `il/generator/` |
| 1.G1.4 | Test: Call to `peek()` generates LDA inline | tests |
| 1.G1.5 | Test: Call to `poke()` generates STA inline | tests |
| 1.G1.6 | Test: Call to all 19 intrinsic stub functions works | tests |

### Intrinsics Mapping Reference

| Stub Function | Generated Code |
|---------------|----------------|
| `peek(addr)` | `LDA addr` |
| `poke(addr, val)` | `STA addr` |
| `peekw(addr)` | `LDA addr / LDX addr+1` |
| `pokew(addr, val)` | `STA addr / STX addr+1` |
| `sei()` | `SEI` |
| `cli()` | `CLI` |
| `nop()` | `NOP` |
| `brk()` | `BRK` |
| `pha()` | `PHA` |
| `pla()` | `PLA` |
| `php()` | `PHP` |
| `plp()` | `PLP` |
| `lo(word)` | Extract low byte |
| `hi(word)` | Extract high byte |
| `sizeof(type)` | Compile-time constant |
| `length(array)` | Compile-time constant |
| `barrier()` | Comment only (no code) |
| `volatile_read(addr)` | `LDA addr` (cannot optimize) |
| `volatile_write(addr, val)` | `STA addr` (cannot optimize) |

---

## Gap 2: String Type as Byte Array Convenience

**Clarification**: String type is a convenience for `byte['h','e','l','l','o']`. Compiler checks for overflow on assignment.

### Problem

String type variables should work:
```js
@data const greeting: string = "Hello";
let message: string[20] = "Hi";
```

### Solution

Strings are **syntactic sugar for byte arrays** with compiler-enforced size checking.

### Rules

1. `string` is equivalent to `byte[]` with null terminator
2. String literals assigned to sized string variables check overflow at compile time
3. `string[N]` declares a byte array of N+1 (includes null terminator)

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 2.G2.1 | Verify string type resolves to byte array in type system | `semantic/type-system.ts` |
| 2.G2.2 | Add compile-time overflow check for string assignment | `semantic/analyzer.ts` |
| 2.G2.3 | Emit error: "String 'XXXX' (N bytes) exceeds buffer size (M bytes)" | `semantic/` |
| 2.G2.4 | Test: `let s: string[5] = "Hello"` â†’ OK (5 chars + null = 6) | tests |
| 2.G2.5 | Test: `let s: string[3] = "Hello"` â†’ ERROR (overflow) | tests |
| 2.G2.6 | Test: String literal generates byte array with null terminator | tests |
| 2.G2.7 | Verify codegen treats string variables as byte arrays | `codegen/` |

### Example

```js
// Source
let name: string[10] = "Bob";

// Equivalent to
let name: byte[11] = ['B', 'o', 'b', 0, 0, 0, 0, 0, 0, 0, 0];  // Null-padded

// Overflow error
let tiny: string[2] = "Hello";  // ERROR: String 'Hello' (6 bytes) exceeds buffer (3 bytes)
```

---

## Gap 3: For Loop Variants (step, downto) + Overflow Checks

**Clarification**: Must implement `step` and `downto`. Compiler must check for overflows as much as possible.

### Problem

The language specification shows:
```js
for (i = 0 to 100 step 2) { }
for (i = 10 downto 0) { }
```

### Solution

Implement both variants with compile-time overflow detection.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 3.G3.1 | Verify IL generator handles `step` keyword | `il/generator/statements.ts` |
| 3.G3.2 | Verify IL generator handles `downto` keyword | `il/generator/statements.ts` |
| 3.G3.3 | Verify codegen emits correct increment for `step N` | `codegen/instruction-generator.ts` |
| 3.G3.4 | Verify codegen emits decrement for `downto` | `codegen/instruction-generator.ts` |
| 3.G3.5 | Add compile-time overflow check: `for (i: byte = 0 to 300)` â†’ ERROR | `semantic/analyzer.ts` |
| 3.G3.6 | Add compile-time step overflow check: `for (i = 0 to 255 step 10)` â†’ WARN (255+10 > 255) | `semantic/` |
| 3.G3.7 | Test: `for (i = 0 to 10 step 2)` generates `i += 2` | tests |
| 3.G3.8 | Test: `for (i = 10 downto 0)` generates `i -= 1` and correct exit condition | tests |
| 3.G3.9 | Test: `for (i = 0 to 10 step 3)` correctly iterates: 0, 3, 6, 9 | tests (VICE) |
| 3.G3.10 | Test: `for (i = 100 downto 90)` correctly iterates: 100, 99, ..., 90 | tests (VICE) |

### Overflow Check Examples

```js
// ERROR: 300 exceeds byte range (0-255)
for (i: byte = 0 to 300) { }

// WARNING: Final step may overflow (250 + 10 = 260 > 255)
for (i: byte = 0 to 250 step 10) { }

// OK: Both within range
for (i: byte = 0 to 200 step 5) { }
```

---

## Gap 4: @address Type Explicit Verification

**Clarification**: Add explicit task to verify @address type works.

### Problem

The `@address` type is used for pointers but isn't explicitly tested in the plan.

### Solution

Add explicit verification tasks.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 4.G4.1 | Verify `@address` type resolves to `word` in type system | `semantic/type-system.ts` |
| 4.G4.2 | Verify `@address` variables allocate 2 bytes | `codegen/globals-generator.ts` |
| 4.G4.3 | Test: `let ptr: @address = $0400` allocates word | tests |
| 4.G4.4 | Test: `@address` arithmetic works (`ptr + 40`) | tests |
| 4.G4.5 | Test: `@address` passed to functions as word | tests |
| 4.G4.6 | Test: `let addr: @address = @buffer` gets address of variable | tests |
| 4.G4.7 | VICE test: Verify @address values correct at runtime | tests (VICE) |

---

## Gap 5: Compile-Time Intrinsics (sizeof, length) - No Runtime Code

**Clarification**: Must be compile-time only. No runtime code generated.

### Problem

`sizeof` and `length` should generate **zero runtime code**.

### Solution

Ensure these intrinsics are evaluated at compile time and substituted as constants.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 5.G5.1 | Verify IL generator resolves `sizeof(type)` at IL generation time | `il/generator/expressions.ts` |
| 5.G5.2 | Verify IL generator resolves `length(array)` at IL generation time | `il/generator/expressions.ts` |
| 5.G5.3 | Verify no INTRINSIC_SIZEOF or INTRINSIC_LENGTH IL opcodes are generated | `il/` |
| 5.G5.4 | Test: `sizeof(byte)` emits `CONST 1`, not function call | tests |
| 5.G5.5 | Test: `sizeof(word)` emits `CONST 2` | tests |
| 5.G5.6 | Test: `sizeof(byte[10])` emits `CONST 10` | tests |
| 5.G5.7 | Test: `length(myArray)` emits `CONST N` where N is array size | tests |
| 5.G5.8 | Verify ASM output has no JSR for sizeof/length | tests |

---

## Gap 6: Multi-Dimensional Array Optimization

**Clarification**: Address partial compile-time optimization for 2D arrays.

### Problem

The spec documents optimization:
```js
screen[5][x] = 160;  // Should compile to: STA screen+200,X
```

### Solution

When row index is constant, compute offset at compile time.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 6.G6.1 | Detect 2D array access with constant row index | `codegen/instruction-generator.ts` |
| 6.G6.2 | Compute partial offset at compile time: `base + (row * rowSize)` | `codegen/instruction-generator.ts` |
| 6.G6.3 | Use indexed addressing for column: `STA computed_offset,Y` | `codegen/instruction-generator.ts` |
| 6.G6.4 | Test: `arr[5][x]` generates `STA arr+offset,Y` (no runtime multiply) | tests |
| 6.G6.5 | Test: `arr[y][x]` generates runtime multiply (both variable) | tests |
| 6.G6.6 | Test: `arr[2][3]` generates direct address (both constant) | tests |
| 6.G6.7 | VICE test: Verify 2D array access correctness | tests (VICE) |

---

## Gap 7: All 19 Intrinsics Explicit Verification

**Clarification**: Enumerate and verify all 19 intrinsics individually.

### Problem

The plan says "15+ intrinsics" but there are actually **19 intrinsics**.

### Solution

Create explicit checklist for all 19.

### Complete Intrinsics Checklist

| # | Intrinsic | Category | Test Required |
|---|-----------|----------|---------------|
| 1 | `peek(addr)` | Memory | âœ… |
| 2 | `poke(addr, val)` | Memory | âœ… |
| 3 | `peekw(addr)` | Memory | âœ… |
| 4 | `pokew(addr, val)` | Memory | âœ… |
| 5 | `sei()` | CPU | âœ… |
| 6 | `cli()` | CPU | âœ… |
| 7 | `nop()` | CPU | âœ… |
| 8 | `brk()` | CPU | âœ… |
| 9 | `pha()` | Stack | âœ… |
| 10 | `pla()` | Stack | âœ… |
| 11 | `php()` | Stack | âœ… |
| 12 | `plp()` | Stack | âœ… |
| 13 | `lo(word)` | Byte | âœ… |
| 14 | `hi(word)` | Byte | âœ… |
| 15 | `sizeof(type)` | Compile-time | âœ… |
| 16 | `length(array)` | Compile-time | âœ… |
| 17 | `barrier()` | Optimization | âœ… |
| 18 | `volatile_read(addr)` | Optimization | âœ… |
| 19 | `volatile_write(addr, val)` | Optimization | âœ… |

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 7.G7.1 | Create intrinsics test file covering all 19 | `__tests__/e2e/intrinsics-complete.test.ts` |
| 7.G7.2 | Verify peek/poke/peekw/pokew (4 tests) | tests |
| 7.G7.3 | Verify sei/cli/nop/brk (4 tests) | tests |
| 7.G7.4 | Verify pha/pla/php/plp (4 tests) | tests |
| 7.G7.5 | Verify lo/hi (2 tests) | tests |
| 7.G7.6 | Verify sizeof/length (2 tests - compile-time) | tests |
| 7.G7.7 | Verify barrier/volatile_read/volatile_write (3 tests) | tests |
| 7.G7.8 | VICE test: Verify intrinsics work at runtime | tests (VICE) |

---

## Gap 8: Enum with Explicit Values Implementation

**Clarification**: Address enums with explicit numeric values.

### Problem

```js
enum Key { 
  UP = 87,
  DOWN = 83,
  LEFT = 65,
  RIGHT = 68
}
```

### Solution

Verify enums with explicit values work correctly.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 8.G8.1 | Verify semantic analyzer stores explicit enum values | `semantic/analyzer.ts` |
| 8.G8.2 | Verify IL generator uses explicit values (not sequential) | `il/generator/` |
| 8.G8.3 | Test: `Key.LEFT` evaluates to 65 (not 2) | tests |
| 8.G8.4 | Test: Mixed explicit/implicit values work | tests |
| 8.G8.5 | Test: Enum comparison with explicit values | tests |
| 8.G8.6 | VICE test: Verify enum values correct at runtime | tests (VICE) |

### Example

```js
enum Mixed {
  A,        // 0 (implicit)
  B = 10,   // 10 (explicit)
  C,        // 11 (implicit, continues from B)
  D = 50    // 50 (explicit)
}
```

---

## Gap 9: Simple and Range @map Verification

**Clarification**: Explicitly verify simple and range @map forms.

### Problem

Phase 2E covers struct @map forms but not simple and range.

### Solution

Add explicit tests for simple and range @map forms.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 9.G9.1 | Test: Simple @map read: `let x = vicBorderColor` | tests |
| 9.G9.2 | Test: Simple @map write: `vicBorderColor = 5` | tests |
| 9.G9.3 | Test: Range @map constant index: `spriteRegs[0] = 100` | tests |
| 9.G9.4 | Test: Range @map variable index: `spriteRegs[i] = x` | tests |
| 9.G9.5 | Verify simple @map generates direct absolute addressing | tests |
| 9.G9.6 | Verify range @map generates indexed addressing | tests |
| 9.G9.7 | VICE test: Verify @map reads/writes work | tests (VICE) |

---

## Gap 10: Multiple Return Statements Edge Cases

**Clarification**: Address multiple returns in same function.

### Problem

```js
function validate(value: byte): boolean {
  if (value > 100) { return false; }
  if (value < 10) { return false; }
  return true;
}
```

### Solution

Verify multiple return paths work correctly.

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 10.G10.1 | Verify PHI lowering handles multiple return merging | `codegen/instruction-generator.ts` |
| 10.G10.2 | Test: Function with 2 return paths | tests |
| 10.G10.3 | Test: Function with 3+ return paths | tests |
| 10.G10.4 | Test: Early return inside loop | tests |
| 10.G10.5 | Test: Nested if with multiple returns | tests |
| 10.G10.6 | VICE test: Verify correct return value for each path | tests (VICE) |

---

## Gap 11: Phase PRE Language Spec Compliance Matrix

**Clarification**: Add comprehensive PRE check with language spec compliance matrix.

### Problem

PRE phase verification is too vague. Need feature-by-feature checklist.

### Solution

Create a Language Specification Compliance Matrix that maps every language feature to verification.

### Language Specification Compliance Matrix

**Add to Phase PRE:**

| Category | Feature | Spec Section | Verification Task |
|----------|---------|--------------|-------------------|
| **Types** | byte | 05 | PRE.M.1 |
| **Types** | word | 05 | PRE.M.2 |
| **Types** | boolean | 05 | PRE.M.3 |
| **Types** | string | 05 | PRE.M.4 |
| **Types** | @address | 05 | PRE.M.5 |
| **Types** | type alias | 05 | PRE.M.6 |
| **Types** | enum | 05 | PRE.M.7 |
| **Operators** | Arithmetic (+,-,*,/,%) | 06 | PRE.M.8 |
| **Operators** | Comparison (==,!=,<,>,<=,>=) | 06 | PRE.M.9 |
| **Operators** | Logical (&&,\|\|,!) | 06 | PRE.M.10 |
| **Operators** | Bitwise (&,\|,^,~,<<,>>) | 06 | PRE.M.11 |
| **Operators** | Compound (+=,-=,etc.) | 06 | PRE.M.12 |
| **Operators** | Unary (-,~,!,@) | 06 | PRE.M.13 |
| **Operators** | Ternary (?:) | 06 | PRE.M.14 |
| **Control Flow** | if/else | 06 | PRE.M.15 |
| **Control Flow** | while | 06 | PRE.M.16 |
| **Control Flow** | do-while | 06 | PRE.M.17 |
| **Control Flow** | for...to | 06 | PRE.M.18 |
| **Control Flow** | for...downto | 06 | PRE.M.19 |
| **Control Flow** | for...step | 06 | PRE.M.20 |
| **Control Flow** | switch/case/default | 06 | PRE.M.21 |
| **Control Flow** | break | 06 | PRE.M.22 |
| **Control Flow** | continue | 06 | PRE.M.23 |
| **Variables** | @zp storage | 10 | PRE.M.24 |
| **Variables** | @ram storage | 10 | PRE.M.25 |
| **Variables** | @data storage | 10 | PRE.M.26 |
| **Variables** | const modifier | 10 | PRE.M.27 |
| **Variables** | Arrays (1D) | 10 | PRE.M.28 |
| **Variables** | Arrays (2D) | 10 | PRE.M.29 |
| **Functions** | No params | 11 | PRE.M.30 |
| **Functions** | With params | 11 | PRE.M.31 |
| **Functions** | Return byte | 11 | PRE.M.32 |
| **Functions** | Return word | 11 | PRE.M.33 |
| **Functions** | Return void | 11 | PRE.M.34 |
| **Functions** | Callback | 11 | PRE.M.35 |
| **Functions** | Export | 11 | PRE.M.36 |
| **@map** | Simple | 12 | PRE.M.37 |
| **@map** | Range | 12 | PRE.M.38 |
| **@map** | Sequential struct | 12 | PRE.M.39 |
| **@map** | Explicit struct | 12 | PRE.M.40 |
| **Intrinsics** | All 19 intrinsics | 13 | PRE.M.41 |
| **Module** | import | 04 | PRE.M.42 |
| **Module** | export | 04 | PRE.M.43 |

### Implementation Tasks

| Task | Description | File |
|------|-------------|------|
| 11.G11.1 | Create PRE compliance matrix spreadsheet/markdown | `plans/codegen-fixes/` |
| 11.G11.2 | Create minimal test program for EACH feature (43 programs) | `fixtures/99-comprehensive/` |
| 11.G11.3 | Run all 43 programs through current compiler | scripts |
| 11.G11.4 | Document pass/fail for each feature | `COMPREHENSIVE-TEST-FAILURES.md` |
| 11.G11.5 | Cross-reference failures to plan phases | docs |
| 11.G11.6 | Add missing phases for any uncovered failures | plan updates |

---

## Summary: All Final Gap Tasks

### Gap 1 Tasks (Stub Functions â†’ Intrinsics)
- [ ] 1.G1.1-1.G1.6 (6 tasks)

### Gap 2 Tasks (String Type)
- [ ] 2.G2.1-2.G2.7 (7 tasks)

### Gap 3 Tasks (For step/downto + Overflow)
- [ ] 3.G3.1-3.G3.10 (10 tasks)

### Gap 4 Tasks (@address Type)
- [ ] 4.G4.1-4.G4.7 (7 tasks)

### Gap 5 Tasks (Compile-time Intrinsics)
- [ ] 5.G5.1-5.G5.8 (8 tasks)

### Gap 6 Tasks (2D Array Optimization)
- [ ] 6.G6.1-6.G6.7 (7 tasks)

### Gap 7 Tasks (All 19 Intrinsics)
- [ ] 7.G7.1-7.G7.8 (8 tasks)

### Gap 8 Tasks (Enum Explicit Values)
- [ ] 8.G8.1-8.G8.6 (6 tasks)

### Gap 9 Tasks (Simple/Range @map)
- [ ] 9.G9.1-9.G9.7 (7 tasks)

### Gap 10 Tasks (Multiple Returns)
- [ ] 10.G10.1-10.G10.6 (6 tasks)

### Gap 11 Tasks (PRE Compliance Matrix)
- [ ] 11.G11.1-11.G11.6 (6 tasks)

**Total New Tasks: 78 tasks**
**Estimated Additional Hours: 25-35 hours (~10-12 sessions)**

---

## Updated Success Criteria

**After implementing this document PLUS all previous phases:**

1. âœ… Stub functions map to intrinsics (no linker needed)
2. âœ… String type works as byte array with overflow checking
3. âœ… For loops with `step` and `downto` work
4. âœ… Compiler checks for loop overflow at compile time
5. âœ… @address type works correctly
6. âœ… sizeof/length generate NO runtime code
7. âœ… 2D arrays optimize constant row access
8. âœ… All 19 intrinsics verified individually
9. âœ… Enums with explicit values work
10. âœ… Simple and Range @map forms verified
11. âœ… Multiple return paths in functions work
12. âœ… 43-feature compliance matrix PASSES

**THEN AND ONLY THEN can we claim "100% working compiler".**

---

## Related Documents

- [Index](00-index.md) - Main plan index
- [Critical Gaps](18-critical-gaps-2026-01-28.md) - Previous gaps
- [Execution Plan](99-execution-plan.md) - Session schedule
- [Language Specification](../../docs/language-specification/) - Source of truth