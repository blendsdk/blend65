// @name: Regression - Loop Variable Scope
// @description: Tests loop variable scoping and shadowing
// @category: regressions
// @expect: success
// @features: for-loop, scope, variables

@map screen at $0400: byte[1000];

// Global variable that might conflict with loop var
let i: byte = 100;
let j: byte = 200;

// Test that for-loop has its own i
function testForLoopScope(): byte {
    let result: byte = 0;
    for (i = 0 to 4) {
        result = result + i;
    }
    return result;  // Should be 0+1+2+3+4 = 10
}

// Test global i is unchanged after loop
function testGlobalUnchanged(): byte {
    let before: byte = i;
    for (i = 0 to 2) {
        // Loop body
    }
    // For loop in Blend uses its own scope for i
    return before;
}

// Test nested loops with same variable name
function testNestedSameVar(): byte {
    let total: byte = 0;
    for (i = 0 to 2) {
        for (i = 0 to 2) {
            total = total + 1;
        }
    }
    return total;  // 3 outer * 3 inner = 9
}

// Test loop var used after loop
function testVarAfterLoop(): byte {
    for (i = 0 to 5) {
        // Count up
    }
    // Loop var may or may not be available here depending on scope rules
    let result: byte = 5;  // Expected final value
    return result;
}

// Test multiple sequential loops
function testSequentialLoops(): byte {
    let sum: byte = 0;
    
    for (i = 0 to 2) {
        sum = sum + i;
    }
    
    for (i = 0 to 2) {
        sum = sum + i;
    }
    
    for (i = 0 to 2) {
        sum = sum + i;
    }
    
    return sum;  // 3 * (0+1+2) = 9
}

// Test while loop with manual counter
function testWhileCounter(): byte {
    let k: byte = 0;
    let sum: byte = 0;
    while (k < 5) {
        sum = sum + k;
        k = k + 1;
    }
    return sum;  // 0+1+2+3+4 = 10
}

// Test loop with array using loop variable
function testLoopArrayIndex(): byte {
    let arr: byte[5];
    for (i = 0 to 4) {
        arr[i] = i * 2;
    }
    let sum: byte = 0;
    for (i = 0 to 4) {
        sum = sum + arr[i];
    }
    return sum;  // 0+2+4+6+8 = 20
}

// Test loop variable in conditional
function testLoopVarInCondition(): byte {
    let count: byte = 0;
    for (i = 0 to 9) {
        if (i > 4) {
            count = count + 1;
        }
    }
    return count;  // 5,6,7,8,9 = 5 items
}

// Main test
function main(): void {
    let r1: byte = testForLoopScope();
    let r2: byte = testGlobalUnchanged();
    let r3: byte = testNestedSameVar();
    let r4: byte = testSequentialLoops();
    let r5: byte = testWhileCounter();
    let r6: byte = testLoopArrayIndex();
    let r7: byte = testLoopVarInCondition();
    
    screen[0] = r1 + 38;
    screen[1] = r2;
    screen[2] = r3 + 48;
    screen[3] = r4 + 48;
    screen[4] = r5 + 38;
    screen[5] = r6 + 28;
    screen[6] = r7 + 48;
}