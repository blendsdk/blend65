// @name: Deeply Nested If Statements
// @description: Tests deeply nested if-else structures
// @category: edge-cases/deeply-nested
// @expect: success
// @features: if-else, control-flow, nesting

@map screen at $0400: byte[1000];

let depth: byte = 0;

// 5 levels of nested if
function nestedIf5(val: byte): byte {
    if (val > 0) {
        if (val > 1) {
            if (val > 2) {
                if (val > 3) {
                    if (val > 4) {
                        return 5;
                    }
                    return 4;
                }
                return 3;
            }
            return 2;
        }
        return 1;
    }
    return 0;
}

// Deeply nested if-else chain
function nestedIfElse(val: byte): byte {
    if (val == 0) {
        return 0;
    } else {
        if (val == 1) {
            return 1;
        } else {
            if (val == 2) {
                return 2;
            } else {
                if (val == 3) {
                    return 3;
                } else {
                    if (val == 4) {
                        return 4;
                    } else {
                        return 5;
                    }
                }
            }
        }
    }
}

// Nested if with multiple conditions per level
function nestedMultiCondition(a: byte, b: byte, c: byte): byte {
    if (a > 0) {
        if (b > 0) {
            if (c > 0) {
                if (a > b) {
                    if (b > c) {
                        return a + b + c;
                    }
                    return a + b;
                }
                return a + c;
            }
            return a;
        }
        return b;
    }
    return c;
}

// Nested if with side effects
function nestedWithSideEffects(val: byte): byte {
    depth = 0;
    if (val > 0) {
        depth = 1;
        if (val > 10) {
            depth = 2;
            if (val > 20) {
                depth = 3;
                if (val > 30) {
                    depth = 4;
                    if (val > 40) {
                        depth = 5;
                    }
                }
            }
        }
    }
    return depth;
}

// Nested if with array access
function nestedWithArray(idx: byte): byte {
    let data: byte[5];
    data[0] = 10;
    data[1] = 20;
    data[2] = 30;
    data[3] = 40;
    data[4] = 50;
    
    if (idx < 5) {
        if (data[idx] > 15) {
            if (data[idx] > 25) {
                if (data[idx] > 35) {
                    if (data[idx] > 45) {
                        return 5;
                    }
                    return 4;
                }
                return 3;
            }
            return 2;
        }
        return 1;
    }
    return 0;
}

// Mixed nesting: if inside loops inside if
function mixedNesting(val: byte): byte {
    let result: byte = 0;
    if (val > 0) {
        for (i = 0 to 2) {
            if (i > 0) {
                for (j = 0 to 1) {
                    if (j == 0) {
                        result = result + 1;
                    }
                }
            }
        }
    }
    return result;
}

// Sequential deep nesting
function sequentialDeep(a: byte, b: byte): byte {
    let r1: byte = 0;
    let r2: byte = 0;
    
    if (a > 0) {
        if (a > 1) {
            if (a > 2) {
                r1 = 3;
            }
        }
    }
    
    if (b > 0) {
        if (b > 1) {
            if (b > 2) {
                r2 = 3;
            }
        }
    }
    
    return r1 + r2;
}

// Main test
function main(): void {
    let r1: byte = nestedIf5(10);
    let r2: byte = nestedIfElse(3);
    let r3: byte = nestedMultiCondition(5, 3, 1);
    let r4: byte = nestedWithSideEffects(35);
    let r5: byte = nestedWithArray(3);
    let r6: byte = mixedNesting(5);
    let r7: byte = sequentialDeep(5, 5);
    
    screen[0] = r1 + 48;
    screen[1] = r2 + 48;
    screen[2] = r3 + 48;
    screen[3] = r4 + 48;
    screen[4] = r5 + 48;
    screen[5] = r6 + 48;
    screen[6] = r7 + 48;
}