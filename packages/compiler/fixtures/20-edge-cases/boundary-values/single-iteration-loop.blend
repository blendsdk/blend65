// @name: Single Iteration Loop Edge Cases
// @description: Tests loops that execute exactly once
// @category: edge-cases/boundary-values
// @expect: success
// @features: for-loop, while-loop, control-flow

@map screen at $0400: byte[1000];

let counter: byte = 0;

// For loop: 0 to 0 (single iteration)
function testForSingleIteration(): byte {
    let count: byte = 0;
    for (i = 0 to 0) {
        count = count + 1;
    }
    return count;
}

// For loop: 5 to 5 (single iteration)
function testForSameValue(): byte {
    let count: byte = 0;
    for (i = 5 to 5) {
        count = count + 1;
    }
    return count;
}

// While loop with immediate exit condition
function testWhileSingleIteration(): byte {
    let count: byte = 0;
    let flag: byte = 1;
    while (flag != 0) {
        count = count + 1;
        flag = 0;
    }
    return count;
}

// Nested single-iteration loops
function testNestedSingleIteration(): byte {
    let count: byte = 0;
    for (i = 0 to 0) {
        for (j = 0 to 0) {
            count = count + 1;
        }
    }
    return count;
}

// While loop with pre-set exit
function testWhilePresetExit(): byte {
    let count: byte = 0;
    let x: byte = 10;
    while (x >= 10) {
        count = count + 1;
        x = 9;
    }
    return count;
}

// For loop with array access on single element
function testSingleElementArray(): byte {
    let arr: byte[1];
    arr[0] = 42;
    let result: byte = 0;
    for (i = 0 to 0) {
        result = arr[i];
    }
    return result;
}

// Multiple single-iteration loops in sequence
function testSequentialSingleLoops(): byte {
    let total: byte = 0;
    
    for (i = 0 to 0) {
        total = total + 1;
    }
    
    for (j = 0 to 0) {
        total = total + 2;
    }
    
    for (k = 0 to 0) {
        total = total + 3;
    }
    
    return total;
}

// Main test
function main(): void {
    let r1: byte = testForSingleIteration();
    let r2: byte = testForSameValue();
    let r3: byte = testWhileSingleIteration();
    let r4: byte = testNestedSingleIteration();
    let r5: byte = testWhilePresetExit();
    let r6: byte = testSingleElementArray();
    let r7: byte = testSequentialSingleLoops();
    
    screen[0] = r1 + 48;
    screen[1] = r2 + 48;
    screen[2] = r3 + 48;
    screen[3] = r4 + 48;
    screen[4] = r5 + 48;
    screen[5] = r6;
    screen[6] = r7 + 48;
}