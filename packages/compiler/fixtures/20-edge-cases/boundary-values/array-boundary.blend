// @name: Array Boundary Edge Cases
// @description: Tests array operations at boundaries
// @category: edge-cases/boundary-values
// @expect: success
// @features: arrays, indexing, loops

@map screen at $0400: byte[1000];

// Small array (1 element)
let singleElement: byte[1];

// Typical array
let normalArray: byte[10];

// Larger array
let largeArray: byte[100];

// Test single element array
function testSingleElement(): byte {
    singleElement[0] = 42;
    return singleElement[0];
}

// Test first element access
function testFirstElement(): byte {
    normalArray[0] = 10;
    return normalArray[0];
}

// Test last element access
function testLastElement(): byte {
    normalArray[9] = 99;
    return normalArray[9];
}

// Test sequential access
function testSequentialAccess(): byte {
    let sum: byte = 0;
    for (i = 0 to 9) {
        normalArray[i] = i;
    }
    for (i = 0 to 9) {
        sum = sum + normalArray[i];
    }
    return sum;
}

// Test reverse access
function testReverseAccess(): byte {
    for (i = 0 to 9) {
        normalArray[i] = i * 2;
    }
    let idx: byte = 9;
    let result: byte = 0;
    while (idx > 0) {
        result = result + normalArray[idx];
        idx = idx - 1;
    }
    result = result + normalArray[0];
    return result;
}

// Test computed index
function testComputedIndex(base: byte): byte {
    normalArray[0] = 5;
    normalArray[1] = 10;
    normalArray[2] = 15;
    normalArray[3] = 20;
    normalArray[4] = 25;
    
    let idx: byte = base + 2;
    if (idx < 10) {
        return normalArray[idx];
    }
    return 0;
}

// Test array copy within bounds
function testArrayCopy(): void {
    for (i = 0 to 9) {
        normalArray[i] = i + 65;  // ASCII A-J
    }
    for (i = 0 to 9) {
        screen[i] = normalArray[i];
    }
}

// Test array with conditional index
function testConditionalIndex(cond: byte): byte {
    normalArray[0] = 100;
    normalArray[5] = 200;
    
    let idx: byte = 0;
    if (cond != 0) {
        idx = 5;
    }
    return normalArray[idx];
}

// Test nested array access (array[array[x]])
function testNestedAccess(): byte {
    normalArray[0] = 3;
    normalArray[1] = 2;
    normalArray[2] = 1;
    normalArray[3] = 0;
    
    let idx: byte = normalArray[0];  // idx = 3
    return normalArray[idx];  // normalArray[3] = 0
}

// Test array in function parameter position
function sumRange(start: byte, count: byte): byte {
    let sum: byte = 0;
    for (i = 0 to 9) {
        if (i >= start) {
            if (i < start + count) {
                sum = sum + normalArray[i];
            }
        }
    }
    return sum;
}

// Test large array boundaries
function testLargeArray(): byte {
    largeArray[0] = 1;
    largeArray[50] = 50;
    largeArray[99] = 99;
    return largeArray[0] + largeArray[99];
}

// Main test
function main(): void {
    let r1: byte = testSingleElement();
    let r2: byte = testFirstElement();
    let r3: byte = testLastElement();
    let r4: byte = testSequentialAccess();
    let r5: byte = testComputedIndex(1);
    testArrayCopy();
    let r6: byte = testConditionalIndex(1);
    let r7: byte = testNestedAccess();
    
    // Setup for sumRange
    for (i = 0 to 9) {
        normalArray[i] = 1;
    }
    let r8: byte = sumRange(2, 3);
    let r9: byte = testLargeArray();
    
    screen[15] = r1;
    screen[16] = r2 + 48;
    screen[17] = r3;
    screen[18] = r4;
    screen[19] = r5 + 48;
}