/**
 * Base Hardware Analyzer
 *
 * Abstract base class for target-specific hardware analyzers.
 * Each target (C64, C128, X16, etc.) extends this class to provide
 * hardware-specific optimization analysis.
 *
 * **Analysis Levels:**
 * This is Level 3 (Target-Specific) in the analysis hierarchy:
 * - Level 1: Universal (language-level, always runs)
 * - Level 2: 6502-Common (CPU-level, all 6502 targets)
 * - Level 3: Target-Specific (hardware-level, per-machine) ‚Üê THIS
 *
 * **Responsibilities:**
 * - Validate hardware-specific memory mappings
 * - Detect hardware resource conflicts
 * - Generate target-specific optimization hints
 * - Enforce hardware timing constraints
 *
 * **Extension Points:**
 * Subclasses must implement:
 * - `analyzeZeroPage()`: Target-specific ZP validation
 * - `analyzeGraphics()`: Graphics chip analysis (VIC-II, VERA, etc.)
 * - `analyzeSound()`: Sound chip analysis (SID, YM2151, etc.)
 * - `getTargetName()`: Human-readable target name
 *
 * @example
 * ```typescript
 * class C64HardwareAnalyzer extends BaseHardwareAnalyzer {
 *   protected analyzeZeroPage(ast: Program): void {
 *     // C64-specific ZP validation
 *   }
 * }
 * ```
 */

import type { Program } from '../../../ast/nodes.js';
import type { SymbolTable } from '../../symbol-table.js';
import type { ControlFlowGraph } from '../../control-flow.js';
import type { Diagnostic } from '../../../ast/diagnostics.js';
import type { SourceLocation } from '../../../ast/base.js';
import { DiagnosticCode, DiagnosticSeverity } from '../../../ast/diagnostics.js';
import type { TargetConfig } from '../../../target/config.js';

/**
 * Hardware analysis result
 *
 * Contains diagnostics and hints generated by hardware analysis.
 */
export interface HardwareAnalysisResult {
  /** Diagnostics (errors, warnings, info) */
  diagnostics: Diagnostic[];

  /** Did analysis complete successfully? */
  success: boolean;

  /** Target that was analyzed */
  targetName: string;
}

/**
 * Base class for hardware-specific analyzers
 *
 * Provides common infrastructure for target-specific analysis.
 * Each supported target extends this class.
 *
 * **Analysis Flow:**
 * 1. `analyze()` is called with the AST
 * 2. Pre-analysis validation runs
 * 3. Target-specific analysis methods are called
 * 4. Post-analysis cleanup runs
 * 5. Results are returned
 */
export abstract class BaseHardwareAnalyzer {
  /** Diagnostics collected during analysis */
  protected diagnostics: Diagnostic[] = [];

  /**
   * Creates a hardware analyzer
   *
   * @param targetConfig - Target configuration for validation
   * @param symbolTable - Symbol table from semantic analysis
   * @param cfgs - Control flow graphs for data flow analysis
   */
  constructor(
    protected readonly targetConfig: TargetConfig,
    protected readonly symbolTable: SymbolTable,
    protected readonly cfgs: Map<string, ControlFlowGraph>
  ) {}

  // ============================================
  // Public API
  // ============================================

  /**
   * Run hardware-specific analysis
   *
   * Main entry point for hardware analysis. Calls all target-specific
   * analysis methods in the correct order.
   *
   * @param ast - Program AST to analyze
   * @returns Analysis result with diagnostics
   */
  public analyze(ast: Program): HardwareAnalysisResult {
    // Clear previous diagnostics
    this.diagnostics = [];

    try {
      // Pre-analysis validation
      this.preAnalysis(ast);

      // Core hardware analysis (target-specific)
      this.analyzeZeroPage(ast);
      this.analyzeGraphics(ast);
      this.analyzeSound(ast);
      this.analyzeMemoryRegions(ast);

      // Post-analysis processing
      this.postAnalysis(ast);

      return {
        diagnostics: [...this.diagnostics],
        success: !this.hasErrors(),
        targetName: this.getTargetName(),
      };
    } catch (error) {
      // Handle unexpected errors gracefully
      this.addError(
        `Hardware analysis failed: ${error instanceof Error ? error.message : String(error)}`,
        ast.getLocation()
      );

      return {
        diagnostics: [...this.diagnostics],
        success: false,
        targetName: this.getTargetName(),
      };
    }
  }

  /**
   * Get all diagnostics from analysis
   *
   * @returns Array of diagnostics
   */
  public getDiagnostics(): Diagnostic[] {
    return [...this.diagnostics];
  }

  /**
   * Check if any errors occurred
   *
   * @returns True if errors exist
   */
  public hasErrors(): boolean {
    return this.diagnostics.some((d) => d.severity === DiagnosticSeverity.ERROR);
  }

  /**
   * Check if any warnings occurred
   *
   * @returns True if warnings exist
   */
  public hasWarnings(): boolean {
    return this.diagnostics.some((d) => d.severity === DiagnosticSeverity.WARNING);
  }

  /**
   * Get target configuration
   *
   * @returns Target configuration used by this analyzer
   */
  public getTargetConfig(): TargetConfig {
    return this.targetConfig;
  }

  // ============================================
  // Abstract Methods (Must be implemented by subclasses)
  // ============================================

  /**
   * Get human-readable target name
   *
   * @returns Target name (e.g., "Commodore 64")
   */
  public abstract getTargetName(): string;

  /**
   * Analyze zero-page usage for target
   *
   * Validates @zp and @map declarations against target's
   * reserved zero-page ranges.
   *
   * @param ast - Program AST
   */
  protected abstract analyzeZeroPage(ast: Program): void;

  /**
   * Analyze graphics hardware usage
   *
   * Validates graphics register access, timing constraints,
   * and resource conflicts for target's graphics chip.
   *
   * @param ast - Program AST
   */
  protected abstract analyzeGraphics(ast: Program): void;

  /**
   * Analyze sound hardware usage
   *
   * Validates sound register access and resource conflicts
   * for target's sound chip.
   *
   * @param ast - Program AST
   */
  protected abstract analyzeSound(ast: Program): void;

  // ============================================
  // Protected Methods (Available to subclasses)
  // ============================================

  /**
   * Pre-analysis hook
   *
   * Called before main analysis. Override to add
   * target-specific setup.
   *
   * @param _ast - Program AST
   */
  protected preAnalysis(_ast: Program): void {
    // Default: no pre-analysis
  }

  /**
   * Post-analysis hook
   *
   * Called after main analysis. Override to add
   * target-specific cleanup or summary.
   *
   * @param _ast - Program AST
   */
  protected postAnalysis(_ast: Program): void {
    // Default: no post-analysis
  }

  /**
   * Analyze memory region usage
   *
   * Validates memory mappings against target's memory regions.
   * Default implementation checks for I/O region access.
   *
   * @param _ast - Program AST
   */
  protected analyzeMemoryRegions(_ast: Program): void {
    // Default: no memory region analysis
    // Subclasses can override for target-specific analysis
  }

  /**
   * Add an error diagnostic
   *
   * @param message - Error message
   * @param location - Source location
   * @param code - Diagnostic code (optional)
   */
  protected addError(
    message: string,
    location: SourceLocation,
    code: DiagnosticCode = DiagnosticCode.TYPE_MISMATCH
  ): void {
    this.diagnostics.push({
      code,
      severity: DiagnosticSeverity.ERROR,
      message,
      location,
    });
  }

  /**
   * Add a warning diagnostic
   *
   * @param message - Warning message
   * @param location - Source location
   * @param code - Diagnostic code (optional)
   */
  protected addWarning(
    message: string,
    location: SourceLocation,
    code: DiagnosticCode = DiagnosticCode.UNUSED_IMPORT
  ): void {
    this.diagnostics.push({
      code,
      severity: DiagnosticSeverity.WARNING,
      message,
      location,
    });
  }

  /**
   * Add an info diagnostic
   *
   * @param message - Info message
   * @param location - Source location
   * @param code - Diagnostic code (optional)
   */
  protected addInfo(
    message: string,
    location: SourceLocation,
    code: DiagnosticCode = DiagnosticCode.UNUSED_IMPORT
  ): void {
    this.diagnostics.push({
      code,
      severity: DiagnosticSeverity.INFO,
      message,
      location,
    });
  }

  /**
   * Check if an address is in zero-page
   *
   * @param address - Address to check
   * @returns True if address is in zero-page (0x00-0xFF)
   */
  protected isZeroPageAddress(address: number): boolean {
    return address >= 0x00 && address <= 0xff;
  }

  /**
   * Check if an address is reserved according to target config
   *
   * @param address - Address to check
   * @returns True if address is reserved
   */
  protected isAddressReserved(address: number): boolean {
    for (const range of this.targetConfig.zeroPage.reservedRanges) {
      if (address >= range.start && address <= range.end) {
        return true;
      }
    }
    return false;
  }

  /**
   * Get reason why an address is reserved
   *
   * @param address - Address to check
   * @returns Reason string, or undefined if not reserved
   */
  protected getReservationReason(address: number): string | undefined {
    for (const range of this.targetConfig.zeroPage.reservedRanges) {
      if (address >= range.start && address <= range.end) {
        return range.reason;
      }
    }
    return undefined;
  }

  /**
   * Check if an address is in the safe zero-page range
   *
   * @param address - Address to check
   * @returns True if address is safe
   */
  protected isAddressSafe(address: number): boolean {
    return (
      address >= this.targetConfig.zeroPage.safeRange.start &&
      address <= this.targetConfig.zeroPage.safeRange.end
    );
  }

  /**
   * Format an address for error messages
   *
   * @param address - Address to format
   * @returns Formatted string (e.g., "$D020")
   */
  protected formatAddress(address: number): string {
    if (address <= 0xff) {
      return `$${address.toString(16).toUpperCase().padStart(2, '0')}`;
    }
    return `$${address.toString(16).toUpperCase().padStart(4, '0')}`;
  }
}