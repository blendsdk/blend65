/**
 * Loop Analysis (Phase 8 - Task 8.11)
 *
 * Performs sophisticated loop analysis for optimization including:
 * - Natural loop detection from CFG back edges
 * - Loop-invariant code identification
 * - Induction variable recognition (basic and derived)
 * - Loop iteration count detection
 * - Loop unrolling candidates
 *
 * **Analysis Only**: This marks opportunities; IL optimizer performs transformations.
 *
 * @example
 * ```typescript
 * const analyzer = new LoopAnalyzer(cfg, symbolTable);
 * analyzer.analyze(ast);
 * 
 * // Check if expression is loop-invariant
 * const isInvariant = expr.metadata?.get(OptimizationMetadataKey.LoopInvariant);
 * ```
 */

import type { Program } from '../../ast/nodes.js';
import type { ControlFlowGraph, CFGNode } from '../control-flow.js';
import type { SymbolTable } from '../symbol-table.js';
import type { Diagnostic } from '../../ast/diagnostics.js';
import { OptimizationMetadataKey } from './optimization-metadata-keys.js';
import { ASTWalker } from '../../ast/walker/base.js';

/**
 * Information about a detected loop
 */
interface LoopInfo {
  /** Loop header node (entry point) */
  header: CFGNode;
  
  /** Set of nodes in loop body */
  body: Set<CFGNode>;
  
  /** Back edge that defines this loop */
  backEdge: { from: CFGNode; to: CFGNode };
  
  /** Loop nesting depth (1 = outermost) */
  depth: number;
  
  /** Loop iteration count (if statically known) */
  iterationCount?: number;
  
  /** Is this loop unrollable? */
  unrollable: boolean;
  
  /** Basic induction variables */
  basicIVs: Map<string, { stride: number; initial: number }>;
  
  /** Derived induction variables */
  derivedIVs: Map<string, { base: string; stride: number }>;
}

/**
 * Loop analysis implementation
 *
 * Detects loops, identifies loop-invariant code, recognizes induction variables,
 * and marks optimization opportunities.
 *
 * Uses natural loop detection algorithm:
 * 1. Find back edges in CFG (edges to dominators)
 * 2. Each back edge defines a natural loop
 * 3. Analyze each loop for optimization opportunities
 */
export class LoopAnalyzer extends ASTWalker {
  /** Diagnostics collected during analysis */
  private diagnostics: Diagnostic[] = [];
  
  /** Detected loops */
  private loops: LoopInfo[] = [];
  
  /** Current loop depth during traversal */
  private currentDepth = 0;
  
  /** CFG for current function */
  private currentCFG: ControlFlowGraph | null = null;

  /**
   * Creates a loop analyzer
   *
   * @param cfgs - Map of function name to CFG
   * @param symbolTable - Symbol table from Pass 1
   */
  constructor(
    private readonly cfgs: Map<string, ControlFlowGraph>,
    private readonly symbolTable: SymbolTable
  ) {
    super();
  }

  /**
   * Analyze program for loop optimization opportunities
   *
   * @param ast - Program AST to analyze
   */
  public analyze(ast: Program): void {
    // Visit all function declarations
    ast.accept(this);
  }

  /**
   * Visit function declaration
   *
   * Analyze loops within this function using its CFG.
   */
  protected visitFunctionDecl(node: any): void {
    const funcName = node.getName();
    this.currentCFG = this.cfgs.get(funcName) || null;
    
    if (this.currentCFG) {
      // Detect all natural loops in this function
      this.detectNaturalLoops(this.currentCFG);
      
      // Analyze each detected loop
      for (const loop of this.loops) {
        this.analyzeLoop(loop, node);
      }
    }
    
    // Reset for next function
    this.loops = [];
    this.currentCFG = null;
    
    // Continue traversal
    super.visitFunctionDecl(node);
  }

  /**
   * Detect natural loops using back edge analysis
   *
   * A back edge is an edge from node N to node H where H dominates N.
   * Each back edge defines a natural loop.
   *
   * @param cfg - Control flow graph
   */
  private detectNaturalLoops(cfg: ControlFlowGraph): void {
    // Compute dominators
    const dominators = this.computeDominators(cfg);
    
    // Find back edges (edges to dominators)
    const backEdges: Array<{ from: CFGNode; to: CFGNode }> = [];
    
    for (const node of cfg.getNodes()) {
      for (const successor of node.successors) {
        // Check if successor dominates node (back edge!)
        if (this.dominates(successor, node, dominators)) {
          backEdges.push({ from: node, to: successor });
        }
      }
    }
    
    // Build natural loop for each back edge
    for (const backEdge of backEdges) {
      const loop = this.buildNaturalLoop(backEdge, cfg);
      this.loops.push(loop);
    }
  }

  /**
   * Compute dominator tree using iterative algorithm
   *
   * A node D dominates node N if every path from entry to N goes through D.
   *
   * @param cfg - Control flow graph
   * @returns Map of node → set of dominators
   */
  private computeDominators(cfg: ControlFlowGraph): Map<CFGNode, Set<CFGNode>> {
    const nodes = Array.from(cfg.getNodes());
    const dominators = new Map<CFGNode, Set<CFGNode>>();
    
    // Initialize: entry dominates only itself, others dominated by all nodes
    for (const node of nodes) {
      if (node === cfg.entry) {
        dominators.set(node, new Set([node]));
      } else {
        dominators.set(node, new Set(nodes));
      }
    }
    
    // Iterate until fixed point
    let changed = true;
    while (changed) {
      changed = false;
      
      for (const node of nodes) {
        if (node === cfg.entry) continue;
        
        // dom(n) = {n} ∪ (∩ dom(p) for all predecessors p)
        const newDom = new Set([node]);
        
        if (node.predecessors.length > 0) {
          // Start with first predecessor's dominators
          const firstPred = node.predecessors[0];
          const intersection = new Set(dominators.get(firstPred) || []);
          
          // Intersect with remaining predecessors
          for (let i = 1; i < node.predecessors.length; i++) {
            const predDom = dominators.get(node.predecessors[i]) || new Set();
            for (const dom of intersection) {
              if (!predDom.has(dom)) {
                intersection.delete(dom);
              }
            }
          }
          
          // Add intersection to new dominators
          for (const dom of intersection) {
            newDom.add(dom);
          }
        }
        
        // Check if changed
        const oldDom = dominators.get(node)!;
        if (newDom.size !== oldDom.size || !this.setsEqual(newDom, oldDom)) {
          dominators.set(node, newDom);
          changed = true;
        }
      }
    }
    
    return dominators;
  }

  /**
   * Check if node D dominates node N
   *
   * @param d - Potential dominator
   * @param n - Node to check
   * @param dominators - Computed dominator sets
   * @returns True if D dominates N
   */
  private dominates(d: CFGNode, n: CFGNode, dominators: Map<CFGNode, Set<CFGNode>>): boolean {
    const domSet = dominators.get(n);
    return domSet ? domSet.has(d) : false;
  }

  /**
   * Build natural loop for a back edge
   *
   * Natural loop = { nodes on any path from header back to itself through back edge }
   *
   * @param backEdge - Back edge defining the loop
   * @param cfg - Control flow graph
   * @returns Loop information
   */
  private buildNaturalLoop(
    backEdge: { from: CFGNode; to: CFGNode },
    cfg: ControlFlowGraph
  ): LoopInfo {
    const header = backEdge.to;
    const body = new Set<CFGNode>([header]);
    
    // Work backwards from back edge source to header
    const worklist: CFGNode[] = [backEdge.from];
    const visited = new Set<CFGNode>([header]);
    
    while (worklist.length > 0) {
      const node = worklist.shift()!;
      
      if (!visited.has(node)) {
        visited.add(node);
        body.add(node);
        
        // Add predecessors to worklist
        for (const pred of node.predecessors) {
          if (!visited.has(pred)) {
            worklist.push(pred);
          }
        }
      }
    }
    
    return {
      header,
      body,
      backEdge,
      depth: 1, // Will be updated later
      unrollable: false,
      basicIVs: new Map(),
      derivedIVs: new Map(),
    };
  }

  /**
   * Analyze a detected loop for optimization opportunities
   *
   * @param loop - Loop information
   * @param funcNode - Function containing the loop
   */
  private analyzeLoop(loop: LoopInfo, funcNode: any): void {
    // 1. Detect induction variables
    this.detectInductionVariables(loop);
    
    // 2. Detect loop-invariant code
    this.detectLoopInvariants(loop);
    
    // 3. Detect iteration count (if possible)
    this.detectIterationCount(loop);
    
    // 4. Check if unrollable
    this.checkUnrollable(loop);
    
    // 5. Set metadata on AST nodes
    this.setLoopMetadata(loop, funcNode);
  }

  /**
   * Detect basic and derived induction variables
   *
   * Basic IV: Variable that changes by constant amount each iteration
   * Derived IV: Variable that's a linear function of a basic IV
   *
   * @param loop - Loop information
   */
  private detectInductionVariables(loop: LoopInfo): void {
    // Phase 1: Find basic induction variables
    // Look for patterns like: i = i + 1, i = i + constant
    
    for (const node of loop.body) {
      if (!node.statement) continue;
      
      // Check for assignment patterns
      if (this.isIncrementPattern(node.statement)) {
        const { variable, stride, initial } = this.extractIncrementInfo(node.statement);
        
        if (variable) {
          loop.basicIVs.set(variable, { stride, initial });
          
          // Set metadata on the variable
          if (node.statement.metadata) {
            node.statement.metadata.set(OptimizationMetadataKey.LoopInductionVariable, true);
            // Store stride in variable metadata if needed
          }
        }
      }
    }
    
    // Phase 2: Find derived induction variables
    // Look for patterns like: j = i * 4, j = i + offset
    
    for (const node of loop.body) {
      if (!node.statement) continue;
      
      if (this.isDerivedIVPattern(node.statement, loop.basicIVs)) {
        const { variable, base, stride } = this.extractDerivedIVInfo(node.statement, loop.basicIVs);
        
        if (variable && base) {
          loop.derivedIVs.set(variable, { base, stride });
          
          // Set metadata
          if (node.statement.metadata) {
            node.statement.metadata.set(OptimizationMetadataKey.LoopInductionVariable, true);
            // TODO: Add metadata for base and stride when keys are defined
          }
        }
      }
    }
  }

  /**
   * Check if statement is an increment pattern (i = i + const)
   */
  private isIncrementPattern(_stmt: any): boolean {
    // Simple pattern matching for now
    // TODO: Expand to handle more patterns
    return false; // Placeholder
  }

  /**
   * Extract increment information from statement
   */
  private extractIncrementInfo(_stmt: any): { variable: string | null; stride: number; initial: number } {
    // TODO: Implement proper pattern extraction
    return { variable: null, stride: 1, initial: 0 };
  }

  /**
   * Check if statement defines a derived induction variable
   */
  private isDerivedIVPattern(_stmt: any, _basicIVs: Map<string, any>): boolean {
    // TODO: Implement derived IV pattern detection
    return false;
  }

  /**
   * Extract derived IV information
   */
  private extractDerivedIVInfo(
    _stmt: any,
    _basicIVs: Map<string, any>
  ): { variable: string | null; base: string | null; stride: number } {
    // TODO: Implement derived IV extraction
    return { variable: null, base: null, stride: 0 };
  }

  /**
   * Detect loop-invariant expressions
   *
   * An expression is loop-invariant if all its operands are:
   * - Constants
   * - Defined outside the loop
   * - Loop-invariant themselves
   *
   * @param loop - Loop information
   */
  private detectLoopInvariants(loop: LoopInfo): void {
    // TODO: Implement loop invariant detection
    // This requires analyzing data dependencies and checking if
    // expression operands are modified within the loop
  }

  /**
   * Detect static iteration count (if possible)
   *
   * @param loop - Loop information
   */
  private detectIterationCount(loop: LoopInfo): void {
    // TODO: Implement iteration count detection
    // Look for simple counted loops: for (i = 0; i < N; i++)
  }

  /**
   * Check if loop can be unrolled
   *
   * Loop is unrollable if:
   * - Has known, small iteration count (< 8)
   * - Has no complex control flow (break/continue)
   * - Body is small enough
   *
   * @param loop - Loop information
   */
  private checkUnrollable(loop: LoopInfo): void {
    if (loop.iterationCount && loop.iterationCount <= 8) {
      loop.unrollable = true;
    }
  }

  /**
   * Set loop metadata on AST nodes
   *
   * @param loop - Loop information
   * @param funcNode - Function containing the loop
   */
  private setLoopMetadata(loop: LoopInfo, _funcNode: any): void {
    // Set metadata on loop header node
    if (loop.header.statement && loop.header.statement.metadata) {
      loop.header.statement.metadata.set(
        OptimizationMetadataKey.LoopIterationCount,
        loop.iterationCount || 0
      );
      // TODO: Add LoopUnrollable key to OptimizationMetadataKey enum
      // loop.header.statement.metadata.set(OptimizationMetadataKey.LoopUnrollable, loop.unrollable);
    }
  }

  /**
   * Check if two sets are equal
   */
  private setsEqual<T>(a: Set<T>, b: Set<T>): boolean {
    if (a.size !== b.size) return false;
    for (const item of a) {
      if (!b.has(item)) return false;
    }
    return true;
  }

  /**
   * Get all diagnostics
   */
  public getDiagnostics(): Diagnostic[] {
    return [...this.diagnostics];
  }
}