// ============================================================================
// C64 Hardware Definitions for Snake Game
// ============================================================================
// Centralized hardware register definitions for Commodore 64.
// Provides type-safe access to VIC-II, CIA, and memory-mapped regions.
//
// Module: Snake.Hardware
// Target: Commodore 64
// ============================================================================

module Snake.Hardware

// ============================================================================
// Screen Memory
// ============================================================================

/**
 * Screen RAM - 40x25 character display
 * Address: $0400-$07E7 (1024 bytes, but only 1000 used)
 * Each byte represents one character on screen
 */
@map screenRAM from $0400 to $07E7: byte;

/**
 * Color RAM - Color attributes for each screen position
 * Address: $D800-$DBE7 (1024 bytes, but only 1000 used)
 * Lower 4 bits define foreground color (0-15)
 */
@map colorRAM from $D800 to $DBE7: byte;

// ============================================================================
// VIC-II Registers (Video Interface Controller)
// ============================================================================

/**
 * VIC-II chip - Complete register map with explicit layout
 * Base address: $D000
 */
@map vic at $D000 layout
  // Sprite positions (16 bytes: X/Y for 8 sprites)
  sprites: from $D000 to $D00F: byte,

  // Sprite X MSB (most significant bit for X > 255)
  spriteXMSB: at $D010: byte,

  // Control register 1
  // Bit 7: Raster compare bit 8
  // Bit 6: Extended color mode
  // Bit 5: Bitmap mode
  // Bit 4: Display enable (0=blank screen)
  // Bit 3: 25/24 row select
  // Bits 2-0: Vertical scroll
  control1: at $D011: byte,

  // Raster line register (read current, write compare)
  raster: at $D012: byte,

  // Light pen X position
  lightPenX: at $D013: byte,

  // Light pen Y position
  lightPenY: at $D014: byte,

  // Sprite enable register (bit 0-7 = sprite 0-7)
  spriteEnable: at $D015: byte,

  // Control register 2
  // Bit 5: Reset (0=normal)
  // Bit 4: Multi-color mode
  // Bit 3: 40/38 column select
  // Bits 2-0: Horizontal scroll
  control2: at $D016: byte,

  // Sprite Y expansion (double height)
  spriteYExpand: at $D017: byte,

  // Memory pointers
  // Bits 7-4: Video matrix base address / 1024
  // Bits 3-1: Character generator base / 2048
  // Bit 0: Unused
  memorySetup: at $D018: byte,

  // Interrupt status register
  // Bit 7: IRQ flag (any enabled interrupt)
  // Bit 3: Light pen triggered
  // Bit 2: Sprite-sprite collision
  // Bit 1: Sprite-background collision
  // Bit 0: Raster compare
  interruptStatus: at $D019: byte,

  // Interrupt enable register (same bits as status)
  interruptEnable: at $D01A: byte,

  // Sprite data priority (0=in front, 1=behind background)
  spriteDataPriority: at $D01B: byte,

  // Sprite multi-color mode enable
  spriteMulticolor: at $D01C: byte,

  // Sprite X expansion (double width)
  spriteXExpand: at $D01D: byte,

  // Sprite-sprite collision detection
  spriteSpriteCollision: at $D01E: byte,

  // Sprite-background collision detection
  spriteBackgroundCollision: at $D01F: byte,

  // Border color (0-15)
  borderColor: at $D020: byte,

  // Background color 0 (main background)
  backgroundColor0: at $D021: byte,

  // Background color 1 (multi-color mode)
  backgroundColor1: at $D022: byte,

  // Background color 2 (multi-color mode)
  backgroundColor2: at $D023: byte,

  // Background color 3 (multi-color mode)
  backgroundColor3: at $D024: byte,

  // Sprite multi-color 0
  spriteMulticolor0: at $D025: byte,

  // Sprite multi-color 1
  spriteMulticolor1: at $D026: byte,

  // Sprite colors (8 bytes for 8 sprites)
  spriteColors: from $D027 to $D02E: byte
end @map

// ============================================================================
// CIA #1 Registers (Complex Interface Adapter)
// ============================================================================

/**
 * CIA #1 - Keyboard and joystick interface
 * Base address: $DC00
 */
@map cia1 at $DC00 layout
  // Data Port A (Joystick 2, Keyboard columns)
  dataPortA: at $DC00: byte,

  // Data Port B (Joystick 1, Keyboard rows)
  dataPortB: at $DC01: byte,

  // Data Direction Register A (0=input, 1=output)
  dataDirA: at $DC02: byte,

  // Data Direction Register B
  dataDirB: at $DC03: byte,

  // Timer A Low byte
  timerALo: at $DC04: byte,

  // Timer A High byte
  timerAHi: at $DC05: byte,

  // Timer B Low byte
  timerBLo: at $DC06: byte,

  // Timer B High byte
  timerBHi: at $DC07: byte,

  // Time of Day: 1/10 seconds
  todTenths: at $DC08: byte,

  // Time of Day: Seconds
  todSeconds: at $DC09: byte,

  // Time of Day: Minutes
  todMinutes: at $DC0A: byte,

  // Time of Day: Hours
  todHours: at $DC0B: byte,

  // Serial Data Register
  serialData: at $DC0C: byte,

  // Interrupt Control Register
  interruptControl: at $DC0D: byte,

  // Control Register A
  controlA: at $DC0E: byte,

  // Control Register B
  controlB: at $DC0F: byte
end @map

// ============================================================================
// Color Constants
// ============================================================================

// Standard C64 color palette (0-15)
const COLOR_BLACK: byte = 0;
const COLOR_WHITE: byte = 1;
const COLOR_RED: byte = 2;
const COLOR_CYAN: byte = 3;
const COLOR_PURPLE: byte = 4;
const COLOR_GREEN: byte = 5;
const COLOR_BLUE: byte = 6;
const COLOR_YELLOW: byte = 7;
const COLOR_ORANGE: byte = 8;
const COLOR_BROWN: byte = 9;
const COLOR_LIGHT_RED: byte = 10;
const COLOR_DARK_GRAY: byte = 11;
const COLOR_GRAY: byte = 12;
const COLOR_LIGHT_GREEN: byte = 13;
const COLOR_LIGHT_BLUE: byte = 14;
const COLOR_LIGHT_GRAY: byte = 15;

// ============================================================================
// Character Codes
// ============================================================================

// Common PETSCII character codes
const CHAR_SPACE: byte = 32;
const CHAR_EXCLAMATION: byte = 33;
const CHAR_HEART: byte = 83;        // ♥ (used for food)
const CHAR_CIRCLE: byte = 81;       // ● (used for snake head)
const CHAR_SMALL_CIRCLE: byte = 87; // ○ (used for snake body)
const CHAR_BLOCK: byte = 160;       // Solid block
const CHAR_ASTERISK: byte = 42;     // * (alternative for food)

// ============================================================================
// Screen Constants
// ============================================================================

const SCREEN_WIDTH: byte = 40;   // Characters per row
const SCREEN_HEIGHT: byte = 25;  // Rows per screen
const SCREEN_SIZE: word = 1000;  // Total screen positions (40 * 25)

// Playable area (leaving room for status line)
const PLAY_WIDTH: byte = 40;     // Full width
const PLAY_HEIGHT: byte = 24;    // Leave bottom row for score

// ============================================================================
// Joystick Constants
// ============================================================================

// Joystick bit masks (inverted logic: 0 = pressed)
const JOY_UP: byte = 0b00000001;
const JOY_DOWN: byte = 0b00000010;
const JOY_LEFT: byte = 0b00000100;
const JOY_RIGHT: byte = 0b00001000;
const JOY_FIRE: byte = 0b00010000;

// Joystick port numbers
const JOY_PORT_1: byte = 1;
const JOY_PORT_2: byte = 2;

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Calculate screen offset from X,Y coordinates.
 *
 * @param x - Column (0-39)
 * @param y - Row (0-24)
 * @returns Screen offset (0-999)
 *
 * @example
 * let offset = screenOffset(10, 5);
 * screenRAM[offset] = CHAR_CIRCLE;
 */
export function screenOffset(x: byte, y: byte): word
  return y * SCREEN_WIDTH + x;
end function

/**
 * Set character and color at screen position.
 *
 * @param x - Column (0-39)
 * @param y - Row (0-24)
 * @param char - Character code
 * @param color - Color code (0-15)
 *
 * @example
 * setChar(10, 5, CHAR_CIRCLE, COLOR_GREEN);
 */
export function setChar(x: byte, y: byte, char: byte, color: byte): void
  let offset: word = screenOffset(x, y);
  screenRAM[offset] = char;
  colorRAM[offset] = color;
end function

/**
 * Get character at screen position.
 *
 * @param x - Column (0-39)
 * @param y - Row (0-24)
 * @returns Character code at position
 *
 * @example
 * let char = getChar(10, 5);
 * if char == CHAR_CIRCLE then
 *   collision();
 * end if
 */
export function getChar(x: byte, y: byte): byte
  let offset: word = screenOffset(x, y);
  return screenRAM[offset];
end function

/**
 * Clear entire screen with specific character and color.
 *
 * @param char - Character to fill with
 * @param color - Color to fill with
 *
 * @example
 * clearScreenWith(CHAR_SPACE, COLOR_BLACK);
 */
export function clearScreenWith(char: byte, color: byte): void
  for i = 0 to SCREEN_SIZE - 1
    screenRAM[i] = char;
    colorRAM[i] = color;
  next i
end function

/**
 * Clear screen to black background with spaces.
 *
 * @example
 * clearScreen();
 */
export function clearScreen(): void
  clearScreenWith(CHAR_SPACE, COLOR_BLACK);
end function

/**
 * Initialize VIC-II for game display.
 *
 * Sets up:
 * - Black border and background
 * - Standard text mode
 * - No sprites enabled
 *
 * @example
 * initDisplay();
 */
export function initDisplay(): void
  // Set colors
  vic.borderColor = COLOR_BLACK;
  vic.backgroundColor0 = COLOR_BLACK;
  vic.backgroundColor1 = COLOR_BLACK;
  vic.backgroundColor2 = COLOR_BLACK;
  vic.backgroundColor3 = COLOR_BLACK;

  // Disable all sprites
  vic.spriteEnable = 0;

  // Standard text mode, display enabled
  vic.control1 = 0b00011011;  // Bit 4=display on, bit 3=25 rows
  vic.control2 = 0b00001000;  // Bit 3=40 columns

  // Clear screen
  clearScreen();
end function

/**
 * Read joystick state from port 2 (most common).
 *
 * @returns Joystick state byte (inverted: 0=pressed)
 *
 * @example
 * let joy = readJoystick();
 * if (joy & JOY_UP) == 0 then
 *   moveUp();
 * end if
 */
export function readJoystick(): byte
  // Joystick 2 is on CIA1 Port A
  return cia1.dataPortA & 0x1F;  // Mask lower 5 bits
end function

/**
 * Check if specific joystick direction is pressed.
 *
 * @param direction - Direction mask (JOY_UP, JOY_DOWN, etc.)
 * @returns True if direction is pressed
 *
 * @example
 * if isJoyPressed(JOY_FIRE) then
 *   startGame();
 * end if
 */
export function isJoyPressed(direction: byte): boolean
  let state: byte = readJoystick();
  // Inverted logic: bit is 0 when pressed
  return (state & direction) == 0;
end function

// ============================================================================
// Implementation Notes
// ============================================================================
//
// Memory Map Summary:
// -------------------
// $0400-$07E7: Screen RAM (1000 bytes)
// $D000-$D02E: VIC-II registers
// $D800-$DBE7: Color RAM (1000 bytes)
// $DC00-$DC0F: CIA #1 registers
//
// VIC-II Control Bits:
// --------------------
// Control 1 ($D011):
//   Bit 7: Raster compare MSB
//   Bit 6: Extended color mode
//   Bit 5: Bitmap mode
//   Bit 4: Display enable
//   Bit 3: 25/24 row select
//   Bits 2-0: Vertical scroll
//
// Control 2 ($D016):
//   Bit 5: Reset
//   Bit 4: Multi-color mode
//   Bit 3: 40/38 column select
//   Bits 2-0: Horizontal scroll
//
// Joystick Reading:
// -----------------
// CIA1 Port A ($DC00): Joystick 2
// CIA1 Port B ($DC01): Joystick 1
// Bits use inverted logic (0 = pressed, 1 = not pressed)
//
// Performance Notes:
// ------------------
// - Direct hardware access via @map has zero overhead
// - Screen offset calculation: ~15-20 cycles
// - Character write: ~10-15 cycles
// - Joystick read: ~8-12 cycles
//
// All functions are designed for maximum 6502 efficiency.
//
// ============================================================================
