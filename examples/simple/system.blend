// ============================================================================
// System Built-In Functions (Compiler Intrinsics)
// ============================================================================
// This module defines the built-in functions provided by the Blend65 compiler.
// These are compiler intrinsics - they have no implementation in Blend code.
// The compiler generates optimized 6502 machine code directly for these functions.
//
// Module: system
// Version: 1.0.0
// Target: Commodore 64 / 6502 Architecture
// ============================================================================

module system

// ============================================================================
// Memory Access Functions
// ============================================================================
// These functions provide direct memory read/write operations, compiled to
// efficient 6502 load/store instructions.
//
// IL Generation: These map to specialized IL nodes (PEEK, POKE, PEEKW, POKEW)
// Code Generation: Compile to LDA/STA instructions with appropriate addressing
// ============================================================================

/**
 * Read a byte from memory at the specified address.
 *
 * This is a compiler intrinsic that generates a single LDA instruction.
 * It provides type-safe memory access without assembly code.
 *
 * @param address - 16-bit memory address to read from
 * @returns Byte value at the specified address
 *
 * @intrinsic intrinsic_peek
 * @codegen LDA (address) or LDA address depending on addressing mode
 * @cycles 4-6 (depends on addressing mode)
 *
 * @example
 * // Read VIC-II border color
 * let borderColor = peek(0xD020);
 *
 * @example
 * // Read from variable address
 * let value = peek(dataPointer);
 */
export function peek(address: word): byte;

/**
 * Write a byte to memory at the specified address.
 *
 * This is a compiler intrinsic that generates a single STA instruction.
 * It provides type-safe memory access without assembly code.
 *
 * @param address - 16-bit memory address to write to
 * @param value - Byte value to write
 *
 * @intrinsic intrinsic_poke
 * @codegen STA address or STA (address) depending on addressing mode
 * @cycles 4-6 (depends on addressing mode)
 *
 * @example
 * // Set VIC-II border color to light blue
 * poke(0xD020, 14);
 *
 * @example
 * // Write to variable address
 * poke(screenPointer, 32); // Write space character
 */
export function poke(address: word, value: byte): void;

/**
 * Read a word (16-bit value) from memory at the specified address.
 *
 * This is a compiler intrinsic that generates optimized code to read
 * a little-endian word (low byte first, then high byte).
 *
 * @param address - 16-bit memory address to read from
 * @returns Word value at the specified address (little-endian)
 *
 * @intrinsic intrinsic_peekw
 * @codegen LDA address / LDX address+1 (or optimized indexed addressing)
 * @cycles 8-12 (two load operations)
 *
 * @example
 * // Read 16-bit timer value from CIA #1
 * let timerValue = peekw(0xDC04);
 *
 * @example
 * // Read pointer from zero page
 * let pointer = peekw(0xFB);
 */
export function peekw(address: word): word;

/**
 * Write a word (16-bit value) to memory at the specified address.
 *
 * This is a compiler intrinsic that generates optimized code to write
 * a little-endian word (low byte first, then high byte).
 *
 * @param address - 16-bit memory address to write to
 * @param value - Word value to write (little-endian)
 *
 * @intrinsic intrinsic_pokew
 * @codegen STA address / STX address+1 (or optimized indexed addressing)
 * @cycles 8-12 (two store operations)
 *
 * @example
 * // Set 16-bit timer value in CIA #1
 * pokew(0xDC04, 0x4000);
 *
 * @example
 * // Write pointer to zero page
 * pokew(0xFB, screenAddress);
 */
export function pokew(address: word, value: word): void;

// ============================================================================
// Compile-Time Intrinsics
// ============================================================================
// These functions are ALWAYS evaluated at compile time.
// They generate NO runtime code - replaced with constant values.
//
// IL Generation: Maps to CONST IL node with computed value
// Code Generation: No code generated - replaced with constant during compilation
// ============================================================================

/**
 * Get the size in bytes of a type or variable.
 *
 * This is a compile-time intrinsic that returns the memory size of a type.
 * It is evaluated during compilation and replaced with a constant value.
 * No runtime code is generated for this function.
 *
 * @param type - Type to get size of (evaluated at compile-time)
 * @returns Size in bytes of the specified type
 *
 * @intrinsic intrinsic_sizeof
 * @codegen No code generated - replaced with compile-time constant
 * @cycles 0 (compile-time only)
 *
 * @example
 * // Basic types
 * let byteSize = sizeof(byte);     // Returns 1
 * let wordSize = sizeof(word);     // Returns 2
 * let boolSize = sizeof(boolean);  // Returns 1
 *
 * @example
 * // Array types
 * let arraySize = sizeof(byte[10]); // Returns 10
 *
 * @example
 * // Allocate buffer based on type size
 * const BUFFER_SIZE: word = sizeof(word) * 100;
 * @data buffer at 0x2000: byte[BUFFER_SIZE];
 */
export function sizeof(t: byte): byte;

/**
 * Get the length of an array or string.
 *
 * This is a compile-time intrinsic that returns the number of elements in an
 * array or the number of characters in a string. Since Blend65 has no dynamic
 * arrays (all array sizes are fixed at compile time), this is ALWAYS evaluated
 * at compile time and replaced with a constant value. No runtime code is
 * generated for this function.
 *
 * The compiler performs special type checking for this intrinsic - it accepts
 * any array type (byte[], word[], etc.) or string type.
 *
 * @param value - Array or string to get length of
 * @returns Number of elements in the array or characters in the string
 *
 * @intrinsic intrinsic_length
 * @codegen No code generated - replaced with compile-time constant
 * @cycles 0 (compile-time only)
 *
 * @example
 * let scores: byte[] = [10, 20, 30, 40, 50];
 * let count = length(scores); // Returns 5 (compile-time constant)
 *
 * @example
 * let positions: word[] = [100, 200, 300];
 * let count = length(positions); // Returns 3 (compile-time constant)
 *
 * @example
 * let message: string = "Hello, C64!";
 * let len = length(message); // Returns 11 (compile-time constant)
 *
 * @example
 * // Iterate over array with known size
 * for i = 0 to length(items) - 1
 *   processItem(items[i]);
 * next i
 */
// NOTE: length() intrinsic removed - array parameter types not yet supported in stub functions
// export function length(value: byte[]): word;

// ============================================================================
// Byte Extraction Utilities
// ============================================================================
// These functions extract high or low bytes from 16-bit word values.
// They are evaluated at compile-time when the argument is a constant,
// otherwise they generate runtime code.
//
// IL Generation: CONST node (for constants) or INTRINSIC_LO/HI node (runtime)
// Code Generation: No code for constants, or LDA zp+1 for hi byte at runtime
// ============================================================================

/**
 * Extract the low byte of a 16-bit word.
 *
 * When the argument is a compile-time constant, this is evaluated at
 * compile time with no runtime cost. When the argument is a variable,
 * this simply takes the low byte (no extra code needed on 6502).
 *
 * @param value - 16-bit word value
 * @returns Low byte (bits 0-7) of the word
 *
 * @intrinsic intrinsic_lo
 * @codegen None (low byte is naturally the first byte in little-endian)
 * @cycles 0 (no extra instructions needed)
 *
 * @example
 * // Compile-time constant extraction
 * let addr: word = $1234;
 * let lowByte = lo(addr);    // $34 (compile-time constant)
 *
 * @example
 * // Runtime extraction (no extra cycles)
 * let value: word = readValue();
 * let low = lo(value);       // Just uses the low byte register
 *
 * @example
 * // Setting up indirect addressing
 * pokew($FB, screenAddress);
 * // OR manually:
 * poke($FB, lo(screenAddress));
 * poke($FC, hi(screenAddress));
 */
export function lo(value: word): byte;

/**
 * Extract the high byte of a 16-bit word.
 *
 * When the argument is a compile-time constant, this is evaluated at
 * compile time with no runtime cost. When the argument is a variable,
 * this requires loading the high byte (typically LDA zp+1 or similar).
 *
 * @param value - 16-bit word value
 * @returns High byte (bits 8-15) of the word
 *
 * @intrinsic intrinsic_hi
 * @codegen LDA zp+1 or LDA abs+1 for runtime values
 * @cycles 0 (constant) or 3-4 (runtime: LDA from high byte location)
 *
 * @example
 * // Compile-time constant extraction
 * let addr: word = $1234;
 * let highByte = hi(addr);   // $12 (compile-time constant)
 *
 * @example
 * // Runtime extraction
 * let value: word = readValue();
 * let high = hi(value);      // LDA from value+1
 *
 * @example
 * // Setting up indirect addressing
 * poke($FB, lo(screenAddress));
 * poke($FC, hi(screenAddress));
 */
export function hi(value: word): byte;

// ============================================================================
// CPU Control Intrinsics
// ============================================================================
// These functions map directly to 6502 CPU instructions for interrupt
// control, timing, and debugging.
//
// IL Generation: Maps to CPU_* IL opcodes
// Code Generation: Single 6502 instruction per intrinsic
// ============================================================================

/**
 * Disable interrupts by setting the interrupt disable flag.
 *
 * This is a compiler intrinsic that generates a single SEI instruction.
 * Use this to create critical sections where interrupts must not occur.
 *
 * @intrinsic cpu_sei
 * @codegen SEI (Set Interrupt Disable)
 * @cycles 2
 *
 * @example
 * // Protect critical section from interrupts
 * sei();
 * // ... critical code that must not be interrupted ...
 * cli();
 *
 * @example
 * // Disable interrupts before modifying interrupt vectors
 * sei();
 * pokew($FFFE, myIRQHandler);
 * cli();
 */
export function sei(): void;

/**
 * Enable interrupts by clearing the interrupt disable flag.
 *
 * This is a compiler intrinsic that generates a single CLI instruction.
 * Use this to re-enable interrupts after a critical section.
 *
 * @intrinsic cpu_cli
 * @codegen CLI (Clear Interrupt Disable)
 * @cycles 2
 *
 * @example
 * // Re-enable interrupts after critical section
 * sei();
 * // ... critical code ...
 * cli();
 */
export function cli(): void;

/**
 * No operation - burn 2 CPU cycles.
 *
 * This is a compiler intrinsic that generates a single NOP instruction.
 * Useful for precise timing control, especially when dealing with
 * hardware that requires specific timing (VIC-II raster effects, etc).
 *
 * @intrinsic cpu_nop
 * @codegen NOP (No Operation)
 * @cycles 2
 *
 * @example
 * // Precise timing delay (each nop is 2 cycles)
 * nop();   // 2 cycles
 * nop();   // 4 cycles total
 * nop();   // 6 cycles total
 *
 * @example
 * // Timing adjustment for raster effects
 * // Wait for exact cycle count before writing to VIC
 * nop();
 * nop();
 * poke($D020, 14);
 */
export function nop(): void;

/**
 * Trigger a software interrupt (BRK instruction).
 *
 * This is a compiler intrinsic that generates a single BRK instruction.
 * BRK pushes the PC+2 and processor status to the stack, then jumps
 * to the IRQ/BRK vector at $FFFE. The B flag distinguishes BRK from IRQ.
 *
 * WARNING: Ensure an appropriate BRK/IRQ handler is installed before using.
 *
 * @intrinsic cpu_brk
 * @codegen BRK (Break)
 * @cycles 7
 *
 * @example
 * // Trigger debugger breakpoint
 * brk();
 *
 * @example
 * // Software interrupt for system calls
 * brk();  // Handler at $FFFE will process
 */
export function brk(): void;

// ============================================================================
// Stack Operation Intrinsics
// ============================================================================
// These functions provide direct access to 6502 stack operations.
// Useful for saving/restoring state in interrupt handlers.
//
// IL Generation: Maps to CPU_PHA/PLA/PHP/PLP IL opcodes
// Code Generation: Single 6502 instruction per intrinsic
//
// WARNING: Stack operations must be balanced! Every push must have a
// corresponding pull, or the stack will become corrupted.
// ============================================================================

/**
 * Push accumulator to stack.
 *
 * This is a compiler intrinsic that generates a single PHA instruction.
 * Saves the current accumulator value to the stack.
 *
 * WARNING: Must be balanced with a corresponding pla() call.
 *
 * @intrinsic cpu_pha
 * @codegen PHA (Push Accumulator)
 * @cycles 3
 *
 * @example
 * // Save and restore accumulator in interrupt handler
 * pha();
 * // ... use accumulator for interrupt work ...
 * pla();  // Restore original value
 */
export function pha(): void;

/**
 * Pull accumulator from stack.
 *
 * This is a compiler intrinsic that generates a single PLA instruction.
 * Restores the accumulator from the stack.
 *
 * WARNING: Must be balanced with a preceding pha() call.
 *
 * @intrinsic cpu_pla
 * @codegen PLA (Pull Accumulator)
 * @cycles 4
 * @returns The byte value pulled from the stack
 *
 * @example
 * // Restore accumulator saved earlier
 * pha();
 * // ... modify accumulator ...
 * pla();  // Accumulator restored to original value
 *
 * @example
 * // Use stack for temporary storage
 * pha();  // Save current value
 * // ... do other work ...
 * let saved = pla();  // Get the saved value back
 */
export function pla(): byte;

/**
 * Push processor status flags to stack.
 *
 * This is a compiler intrinsic that generates a single PHP instruction.
 * Saves all processor flags (N, V, -, B, D, I, Z, C) to the stack.
 *
 * WARNING: Must be balanced with a corresponding plp() call.
 *
 * @intrinsic cpu_php
 * @codegen PHP (Push Processor Status)
 * @cycles 3
 *
 * @example
 * // Save and restore processor flags in interrupt handler
 * php();
 * // ... operations that modify flags ...
 * plp();  // Restore original flags
 */
export function php(): void;

/**
 * Pull processor status flags from stack.
 *
 * This is a compiler intrinsic that generates a single PLP instruction.
 * Restores all processor flags from the stack.
 *
 * WARNING: Must be balanced with a preceding php() call.
 * NOTE: This modifies ALL processor flags including interrupt disable.
 *
 * @intrinsic cpu_plp
 * @codegen PLP (Pull Processor Status)
 * @cycles 4
 *
 * @example
 * // Restore flags saved earlier
 * php();
 * // ... operations that modify flags ...
 * plp();  // All flags restored to original state
 */
export function plp(): void;

// ============================================================================
// Optimization Control Intrinsics
// ============================================================================
// These functions control compiler optimization behavior for timing-critical
// code and hardware access where optimizations could cause incorrect behavior.
//
// IL Generation: Maps to OPT_BARRIER, VOLATILE_READ, VOLATILE_WRITE IL opcodes
// Code Generation: barrier() = no code, volatile_* = forced memory access
// ============================================================================

/**
 * Insert an optimization barrier.
 *
 * This is a compiler intrinsic that prevents the optimizer from reordering
 * code across this point. Useful for ensuring specific instruction ordering
 * when dealing with hardware that has timing requirements.
 *
 * Generates no actual code - this is a directive to the optimizer only.
 *
 * @intrinsic opt_barrier
 * @codegen None (optimizer directive only)
 * @cycles 0
 *
 * @example
 * // Ensure writes happen in specific order
 * poke($D020, 14);
 * barrier();
 * poke($D021, 6);
 *
 * @example
 * // Prevent loop hoisting of hardware reads
 * while true
 *   barrier();
 *   let status = peek($DC0D);
 *   if status & 1
 *     break;
 *   end if
 * end while
 */
export function barrier(): void;

/**
 * Perform a volatile memory read that cannot be optimized away.
 *
 * This is a compiler intrinsic that reads from memory in a way that:
 * - Cannot be cached or eliminated by the optimizer
 * - Cannot be reordered with other volatile operations
 * - Always generates an actual memory read
 *
 * Essential for reading hardware registers where the read itself has
 * side effects (like clearing interrupt flags).
 *
 * @param address - 16-bit memory address to read from
 * @returns Byte value at the specified address
 *
 * @intrinsic volatile_read
 * @codegen LDA address (forced, cannot be optimized away)
 * @cycles 4
 *
 * @example
 * // Read CIA interrupt control register (reading clears flags)
 * let status = volatile_read($DC0D);  // Must actually read!
 *
 * @example
 * // Polling a hardware status register
 * while (volatile_read($D012) & $80) == 0
 *   // Wait for raster line
 * end while
 */
export function volatile_read(address: word): byte;

/**
 * Perform a volatile memory write that cannot be optimized away.
 *
 * This is a compiler intrinsic that writes to memory in a way that:
 * - Cannot be eliminated by the optimizer
 * - Cannot be reordered with other volatile operations
 * - Always generates an actual memory write
 *
 * Essential for writing to hardware registers where the write must
 * actually occur (even if the value appears unchanged).
 *
 * @param address - 16-bit memory address to write to
 * @param value - Byte value to write
 *
 * @intrinsic volatile_write
 * @codegen STA address (forced, cannot be optimized away)
 * @cycles 4
 *
 * @example
 * // Write to hardware register (must actually write)
 * volatile_write($D020, 0);  // Cannot be eliminated
 *
 * @example
 * // Acknowledge interrupt (write to clear)
 * volatile_write($DC0D, $7F);  // Clear all CIA interrupts
 */
export function volatile_write(address: word, value: byte): void;

// ============================================================================
// Implementation Notes
// ============================================================================
//
// Stub Functions vs Intrinsics:
// ------------------------------
// These functions are declared without bodies (stub functions) because they
// are implemented directly by the compiler. During semantic analysis:
//
// 1. Symbol Table Builder: Registers these as function symbols
// 2. Type Checker: Validates call sites use correct parameter types
// 3. IL Generator: Emits specialized IL nodes (PEEK, POKE, CPU_*, etc.)
// 4. Code Generator: Generates optimized 6502 machine code
//
// Intrinsic Categories:
// ---------------------
// - Memory Access: peek, poke, peekw, pokew (direct memory operations)
// - Compile-Time: sizeof, length (replaced with constants)
// - Byte Extraction: lo, hi (compile-time for constants, runtime otherwise)
// - CPU Control: sei, cli, nop, brk (6502 instruction mapping)
// - Stack Operations: pha, pla, php, plp (6502 stack instructions)
// - Optimization: barrier, volatile_read, volatile_write (optimizer control)
//
// Type Safety:
// ------------
// Even though these are intrinsics, they maintain full type safety:
// - peek/poke enforce byte values
// - peekw/pokew enforce word values
// - lo/hi return byte from word input
// - length returns word type for maximum array size support
// - sizeof returns byte (max type size is 255 bytes)
// - Stack operations are properly typed
//
// Performance Characteristics:
// ----------------------------
// - peek/poke: 4-6 cycles (single LDA/STA instruction)
// - peekw/pokew: 8-12 cycles (two load/store operations)
// - length: 0 cycles (compile-time constant)
// - sizeof: 0 cycles (compile-time constant)
// - lo: 0 cycles (compile-time for constants, 0 cycles runtime)
// - hi: 0 cycles (compile-time) or 3-4 cycles (runtime LDA)
// - sei/cli/nop: 2 cycles each
// - brk: 7 cycles
// - pha/php: 3 cycles each
// - pla/plp: 4 cycles each
// - barrier: 0 cycles (no code generated)
// - volatile_read/write: 4 cycles (forced memory access)
//
// Memory Safety:
// --------------
// These functions provide low-level memory access and bypass normal memory
// safety. Use with caution:
// - No bounds checking on addresses
// - No validation of memory regions
// - Can corrupt program state if misused
// - Essential for C64 hardware programming
//
// Stack Safety:
// -------------
// Stack operations (pha/pla/php/plp) must be balanced:
// - Every pha() must have a corresponding pla()
// - Every php() must have a corresponding plp()
// - Unbalanced stacks cause crashes or undefined behavior
//
// ============================================================================